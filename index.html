<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b1220" />

  <title>Logi2 v0.8.3s2</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest?v=0.8.3s2">
  <link rel="icon" href="favicon.png?v=0.8.3s2">
  <link rel="apple-touch-icon" href="apple-touch-icon.png?v=0.8.3s2">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- JSZip (ZIP) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <!-- DOCX (Word) -->
  <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>

  <!-- XLSX (Excel import) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
<style>
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}

    :root{
      /* Base (oscuro sobrio) */
      --bg:#0b1220;
      --card:#0a1020;
      --card2:#050a14;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --border:#223047;

      /* Acento */
      --accent:#3b82f6;
      --accent2:#60a5fa;
      --accent-rgb:59,130,246;

      /* UI */
      --danger:#ef4444;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    :root[data-theme="light"]{
      --bg:#f5f7fb;
      --card:#ffffff;
      --card2:#ffffff;
      --text:#0f172a;
      --muted:#475569;
      --border:#d6deea;

      --accent:#2563eb;
      --accent2:#3b82f6;
      --accent-rgb:37,99,235;

      --danger:#ef4444;
      --shadow:0 10px 24px rgba(15,23,42,.10);
    }
    body{margin:0;padding:14px;background:var(--bg);color:var(--text)}
    .wrap{max-width:900px;margin:0 auto;display:grid;gap:12px}
    h1{font-size:1.15rem;margin:4px 0 0;text-align:center}
    .card{background:var(--card2);border:1px solid var(--border);border-radius:14px;padding:12px;box-shadow:var(--shadow)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-size:.8rem;color:var(--muted);display:block;margin-bottom:4px}
    input[type="date"], select, textarea{width:100%;padding:10px;border-radius:12px;border:1px solid var(--border);background:var(--card);color:var(--text);font-size:.95rem}
    textarea{min-height:44px;resize:vertical}
    input[type="text"]{width:100%;padding:10px;border-radius:12px;border:1px solid var(--border);background:var(--card);color:var(--text);font-size:.95rem}
    .btn{
      border:0;border-radius:999px;padding:10px 14px;font-weight:700;cursor:pointer;
      display:inline-flex;align-items:center;gap:8px;font-size:.92rem;
      user-select:none;-webkit-user-select:none;touch-action:manipulation;
    }
    .btn-primary{background:var(--accent);color:white}
    .btn-secondary{background:var(--card);color:var(--text);border:1px solid var(--border)}
    .btn-danger{background:#ef4444;color:#fee2e2}
    .btn-disabled{opacity:.45;cursor:not-allowed}
    .muted{color:var(--muted);font-size:.8rem}
    .pill{font-size:.72rem;letter-spacing:.08em;text-transform:uppercase;padding:4px 10px;border-radius:999px;background:rgba(var(--accent-rgb),.14);border:1px solid rgba(var(--accent-rgb),.22);color:var(--text);font-weight:900}
    .chip-done{
      font-size:.72rem;letter-spacing:.08em;text-transform:uppercase;
      padding:4px 10px;border-radius:999px;background:#34d399;color:#052e1a;font-weight:900
    }
    .status{font-size:.85rem;color:var(--text)}
    .ok{color:#34d399}

    .list{display:grid;gap:10px;margin-top:10px}
    .item{border:1px solid var(--border);border-radius:14px;padding:10px;background:var(--card)}
    .item.done{border-color:#34d39955}
    .itemTop{display:flex;gap:10px;align-items:flex-start}
    .thumb{width:72px;height:72px;border-radius:12px;object-fit:cover;border:1px solid var(--border);cursor:pointer}
    .grow{flex:1}
    .mini{font-size:.78rem;color:#9ca3af;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .right{margin-left:auto;display:flex;gap:8px;align-items:center}
    .smallBtn{padding:8px 10px;font-size:.85rem}

    .tabs{display:flex;gap:8px;align-items:center}
    .tab{border:1px solid var(--border);background:var(--card);color:var(--text);border-radius:999px;padding:8px 12px;font-weight:800;cursor:pointer;font-size:.88rem}
    .tab.active{background:rgba(var(--accent-rgb),.16);border-color:rgba(var(--accent-rgb),.30);color:var(--text)}

    /* Plantilla de p√°gina (4/6/8) */
    .layoutPick{display:flex;gap:10px;flex-wrap:wrap}
    .layoutBtn{flex:1;min-width:92px;border:1px solid var(--border);background:var(--card);color:var(--text);border-radius:14px;padding:10px;cursor:pointer;text-align:center;box-shadow:0 6px 16px rgba(0,0,0,.12)}
    :root[data-theme="light"] .layoutBtn{box-shadow:0 6px 14px rgba(15,23,42,.08)}
    .layoutBtn.active{border-color:rgba(var(--accent-rgb),.45);background:rgba(var(--accent-rgb),.14)}
    .layoutGrid{display:grid;gap:3px;justify-content:center;align-content:center;margin:0 auto;width:64px;height:44px;padding:6px;border-radius:12px;border:1px solid var(--border);background:rgba(var(--accent-rgb),.06)}
    .layoutGrid span{display:block;border-radius:3px;background:rgba(203,213,225,.75)}
    :root[data-theme="light"] .layoutGrid span{background:rgba(15,23,42,.15)}
    .layoutLabel{margin-top:6px;font-weight:900;font-size:.95rem}

    details.adv{margin-top:10px;border:1px solid var(--border);border-radius:14px;background:var(--card);padding:10px}
    details.adv summary{cursor:pointer;font-weight:900;color:var(--text);list-style:none}
    details.adv summary::-webkit-details-marker{display:none}
    details.adv summary:before{content:"‚ñ∏";display:inline-block;margin-right:8px;color:var(--muted);transform:translateY(-1px)}
    details.adv[open] summary:before{content:"‚ñæ"}


    .galleryWrap{margin-top:10px;border:1px solid var(--border);border-radius:14px;background:var(--card);overflow:visible}
    .dayHeader{
  position:sticky; top:0;
  background:var(--card);
  border-bottom:1px solid var(--border);
  padding:10px 12px;
  z-index:5;
  display:flex;align-items:center;gap:10px;flex-wrap:wrap;
}
.dayChip{
  display:inline-flex;align-items:center;gap:8px;
  padding:6px 10px;border-radius:999px;
  background:rgba(var(--accent-rgb),.14);
  border:1px solid rgba(var(--accent-rgb),.26);
  font-weight:900;
}
.dayTitle{font-weight:900}
.dayMeta{color:var(--muted);font-size:.8rem}
    .gridThumbs{
      display:grid;
      grid-template-columns:repeat(3, minmax(0,1fr));
      gap:8px;
      padding:10px 12px 14px;
    }
    @media (min-width: 768px){
      .gridThumbs{grid-template-columns:repeat(6, minmax(0,1fr));}
    }
    .gThumbBox{position:relative}
    .gThumb{
      width:100%;
      aspect-ratio:1/1;
      object-fit:cover;
      border-radius:12px;
      border:1px solid var(--border);
      cursor:pointer;
      display:block;
    }
    .badge{
      position:absolute;
      left:8px; top:8px;
      padding:3px 8px;
      border-radius:999px;
      font-size:.68rem;
      font-weight:900;
      background:rgba(15,23,42,.8);
      border:1px solid rgba(203,213,225,.25);
      color:#e5e7eb;
    }
    .badgeDone{
      background:rgba(52,211,153,.9);
      color:#052e1a;border-color:transparent;
    }
    .badgeShare{ right:8px; left:auto; }

    /* √çtems (overlay en miniaturas) */
    .badgeItem{ top:auto; bottom:8px; font-size:.62rem; padding:2px 7px; letter-spacing:.2px; }
    .badgeItemOk{ background:rgba(96,165,250,.92); color:#071125; border-color:transparent; }
    .badgeItemMiss{ background:rgba(248,113,113,.92); color:#2b0707; border-color:transparent; }
    .gThumbMissing{ border-color: rgba(248,113,113,.9); box-shadow: 0 0 0 2px rgba(248,113,113,.18); }
    .thumbMissing{ border-color: rgba(248,113,113,.9) !important; box-shadow: 0 0 0 2px rgba(248,113,113,.18); }


    .modal{position:fixed; inset:0;background:rgba(2,6,23,.92);display:none; align-items:center; justify-content:center;z-index:200; padding:14px;}
    .modal.open{display:flex}
    .modalCard{width:min(980px, 96vw);background:var(--card2);border:1px solid var(--border);border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.6);overflow:hidden;}
    .modalBody{display:grid;gap:0}
    @media (min-width: 900px){
      .modalBody{grid-template-columns: 1.25fr .75fr}
    }
    .modalImg{width:100%;max-height:70vh;object-fit:contain;background:var(--card);}
    .modalSide{padding:12px;display:grid;gap:10px;align-content:start;background:var(--card2);}
    .modalTitle{font-weight:900}
    .modalCloseRow{display:flex;justify-content:space-between;align-items:center;gap:10px}

    /* ‚úÖ Android/PWA: NO usar display:none en file inputs */
    .hiddenFileInput{
      position: fixed;
      left: -9999px;
      top: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }

    /* Barra de actualizaci√≥n */
    .updateBar{
      display:none;
      margin-top:10px;
      border:1px solid rgba(var(--accent-rgb),.30);
      background:rgba(var(--accent-rgb),.10);
      padding:10px 12px;
      border-radius:14px;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .updateBar.show{display:flex}
    .glowBtn{
      box-shadow: 0 0 0 rgba(var(--accent-rgb),0);
      animation: glow 1.2s ease-in-out infinite;
    }
    @keyframes glow{
      0%{ box-shadow: 0 0 0 rgba(var(--accent-rgb),0); }
      50%{ box-shadow: 0 0 22px rgba(var(--accent-rgb),.35); }
      100%{ box-shadow: 0 0 0 rgba(var(--accent-rgb),0); }
    }

    /* App bar */
    .appbar{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:12px 12px 6px;
    }
    .appbarLeft{display:grid;gap:2px;min-width:0}
.appTitleRow{display:flex;align-items:baseline;gap:10px;min-width:0}
    .appVersion{font-size:.78rem;color:var(--muted);font-weight:800;white-space:nowrap;flex:0 0 auto}
    .appTitle{
      font-size:1.25rem;
      font-weight:950;
      letter-spacing:.2px;
      line-height:1.1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .appSubtitle{font-size:.82rem;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .iconBtn{
      width:44px;height:44px;border-radius:14px;
      background:var(--card2);border:1px solid var(--border);
      display:grid;place-items:center;cursor:pointer;
      box-shadow:var(--shadow);
      user-select:none;-webkit-user-select:none;
      position:relative;
    }
    .iconBtn.hasUpdate::after{
      content:"";
      position:absolute;
      width:10px;height:10px;border-radius:50%;
      right:8px;top:8px;
      background:rgba(var(--accent-rgb),1);
      box-shadow:0 0 0 4px rgba(var(--accent-rgb),.18);
    }
    .iconBtn .icon{font-size:1.15rem}

    /* Tabs: ancho completo */
    .tabs{
      width:100%;
      gap:0;
      background:var(--card);
      border:1px solid var(--border);
      padding:4px;
      border-radius:999px;
      display:flex;
      align-items:center;
    }
    .tab{
      flex:1;
      text-align:center;
    }

    /* Bottom sheet */
    .sheetBackdrop{
      position:fixed;inset:0;
      background:rgba(2,6,23,.55);
      display:none;
      z-index:80;
      padding:0;
    }
    .sheetBackdrop.open{display:block}
    .sheet{
      position:absolute;
      left:0;right:0;bottom:0;
      background:var(--card2);
      border:1px solid var(--border);
      border-bottom:none;
      border-radius:18px 18px 0 0;
      box-shadow:0 -18px 60px rgba(0,0,0,.55);
      transform:translateY(110%);
      transition:transform .22s ease;
      touch-action:none;
      max-height:85vh;
      overflow:hidden;
    }
    .sheet.open{transform:translateY(0)}
    .sheetHandle{
      width:54px;height:6px;border-radius:999px;
      background:rgba(148,163,184,.35);
      margin:10px auto 6px;
    }
    .sheetHeader{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:8px 12px 10px;
      border-bottom:1px solid var(--border);
    }
    .sheetTitle{font-weight:950;font-size:1.02rem}
    .sheetBody{
      padding:12px;
      display:grid;
      gap:10px;
      overflow:auto;
      max-height:calc(85vh - 70px);
    }
    .sheetRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 10px;
      border:1px solid var(--border);
      border-radius:14px;
      background:var(--card);
    }
    .sheetRow.dangerRow{border-color:rgba(239,68,68,.35);background:rgba(239,68,68,.08)}
    .sheetRowMain{min-width:0}
    .sheetRowTitle{font-weight:900}
    .accentPalette{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .accentDot{
      width:22px;height:22px;border-radius:999px;
      border:2px solid rgba(255,255,255,.22);
      box-shadow:0 8px 18px rgba(0,0,0,.22);
      cursor:pointer;
      position:relative;
    }
    .storageBar{
      height:10px;
      border-radius:999px;
      background:var(--border);
      overflow:hidden;
      margin-top:-4px;
    }
    .storageFill{
      height:100%;
      width:0%;
      background:rgba(var(--accent-rgb),.75);
      transition:width .25s ease;
    }

    :root[data-theme="light"] .accentDot{border:2px solid rgba(15,23,42,.18)}
    .accentDot.active::after{
      content:"‚úì";
      position:absolute;inset:0;
      display:grid;place-items:center;
      font-size:.85rem;font-weight:950;
      color:white;
      text-shadow:0 2px 10px rgba(0,0,0,.6);
    }
    :root[data-theme="light"] .accentDot.active::after{color:#0f172a;text-shadow:none}

  
    /* ===========================
       üß© Multi-proyecto (Logi2)
    ============================ */
    .projectBar{
      margin-top:10px;
      border:1px solid rgba(var(--accent-rgb),.26);
      background:rgba(var(--accent-rgb),.08);
      border-radius:14px;
      padding:10px 12px;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .projectBarTitle{font-weight:950}
    .projectBarRight{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .projectSelect{min-width:220px;max-width:420px}
    .projModalCard{width:min(560px, 96vw)}

  </style>
</head>

<body>
  <div class="wrap">
        <!-- Inputs ocultos (global) -->
        <input id="logoInput" class="hiddenFileInput" type="file" accept="image/*" />
        <input id="backupInput" class="hiddenFileInput" type="file" accept=".zip,application/zip" />
        <input id="itemsInput" class="hiddenFileInput" type="file" accept=".xlsx,.xls,.csv,text/csv,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" />

    <div class="appbar">
      <div class="appbarLeft">
        <div class="appTitleRow">
          <div class="appTitle">Logi</div>
          <div class="appVersion" id="appVersion">v0.8.3s2</div>
        </div>
      </div>
      <button class="iconBtn" id="btnSettings" aria-label="Configuraci√≥n">
        <span class="icon">‚öôÔ∏è</span>
      </button>
    </div>

    <div class="card">
      
      <div class="row" style="justify-content:flex-end;align-items:flex-start">
        <div class="right">
          <div id="status" class="status"></div>
        </div>
      </div>
      <!-- Proyecto activo (Logi2) -->
      <div class="projectBar" id="projectBar">
        <div style="min-width:220px">
          <div class="projectBarTitle">Proyecto activo</div>
          <div class="muted">Este proyecto separa tus fotos y exportes.</div>
        </div>
        <div class="projectBarRight">
          <select id="projectSelect" class="projectSelect"></select>
          <button class="btn btn-secondary smallBtn" id="btnProjectRename" title="Renombrar proyecto">‚úèÔ∏è</button>
          <button class="btn btn-primary smallBtn" id="btnProjectNew" title="Nuevo proyecto">‚ûï</button>
        </div>
      </div>



      <!-- Barra de update -->
      <div class="updateBar" id="updateBar">
        <div class="muted">
          Hay una versi√≥n nueva lista. (Tip: si te da miedo perder algo, exporta HOY antes de actualizar.)
        </div>
        <button class="btn btn-primary smallBtn glowBtn" id="btnUpdateNow">‚úÖ Instalar actualizaci√≥n</button>
      </div>

      
      <div class="tabs" style="margin-top:10px;">
        <button class="tab active" id="tabCaptura">Captura</button>
        <button class="tab" id="tabGaleria">Galer√≠a</button>
        <button class="tab" id="tabExport">Exportar</button>
      </div>


      <div id="capturaControls">
      <div class="row" style="margin-top:10px;">
        <div style="flex:1;min-width:220px">
          <label for="fecha">Fecha</label>
          <input type="date" id="fecha" />
        </div>

        <div style="flex:1;min-width:220px">
          <label for="proyecto">Proyecto (opcional)</label>
          <input type="text" id="proyecto" placeholder="PTAR Cumaral, Malec√≥n, etc." />
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <input id="camInput" class="hiddenFileInput" type="file" accept="image/*" capture="environment" multiple />
        <input id="galInput" class="hiddenFileInput" type="file" accept="image/*" multiple />
        <button class="btn btn-primary" id="btnTomarFoto">üì∑ C√°mara</button>
        <button class="btn btn-secondary" id="btnGaleria">üñºÔ∏è Galer√≠a</button>
      </div>
      </div>

      <div id="capturaView">
        <div class="muted" style="margin-top:8px">
          Captura del d√≠a: escribe la descripci√≥n, marca ‚úÖ Listo y si quieres üì§ WhatsApp (solo imagen).
        </div>

        <div id="lista" class="list"></div>
      </div>

      <div id="galeriaView" style="display:none">
        
        <div class="row" style="margin-top:10px;align-items:flex-end;gap:10px;flex-wrap:wrap">
          <div style="flex:1;min-width:260px">
            <label for="galleryItem">Filtrar por √≠tem (opcional)</label>
            <input type="text" id="galleryItem" list="datalistItems" placeholder="C√≥digo o busca en el listado‚Ä¶" />
            <div class="muted" id="galleryItemHint" style="margin-top:6px">‚Äî</div>
          </div>
          <button class="btn btn-secondary smallBtn" id="btnGalleryItemClear" title="Quitar filtro">‚úñ</button>
        </div>
<div class="muted" style="margin-top:8px">
          Miniaturas por d√≠a. El encabezado del d√≠a se queda pegado arriba al hacer scroll.
        </div>
        <div class="muted" id="rangeInfo" style="margin-top:6px">Rango: ‚Äî</div>
        <div id="galleryWrap" class="galleryWrap"></div>
      </div>
    </div>

    <div id="exportView" style="display:none">
<div class="card">
      <div class="row" style="justify-content:space-between;">
        <span class="pill">Exportar</span>
</div>

      <div class="row" style="margin-top:10px;">
        <div style="flex:1;min-width:180px">
          <label for="modoExport">Modo</label>
          <select id="modoExport">
            <option value="dia">D√≠a</option>
            <option value="mes">Mes</option>
            <option value="rango">Rango</option>
          </select>
        </div>

        <div id="desdeWrap" style="flex:1;min-width:180px">
          <label id="desdeLabel" for="desde">Desde</label>
          <input type="date" id="desde" />
        </div>

        <div id="hastaWrap" style="flex:1;min-width:180px">
          <label for="hasta">Hasta</label>
          <input type="date" id="hasta" />
        </div>
      </div>

      <div class="row" style="margin-top:10px;align-items:flex-end;gap:10px;flex-wrap:wrap">
        <div style="flex:1;min-width:260px">
          <label for="exportItem">Filtrar por √≠tem (opcional)</label>
          <input type="text" id="exportItem" list="datalistItems" placeholder="C√≥digo o busca en el listado‚Ä¶" />
          <div class="muted" id="exportItemHint" style="margin-top:6px">‚Äî</div>
        </div>
        <button class="btn btn-secondary smallBtn" id="btnClearExportItem" title="Quitar filtro">‚úñ</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <div style="flex:1;min-width:220px">
          <label>Plantilla de p√°gina (fotos por p√°gina)</label>
          <div class="layoutPick" id="layoutPick">
            <button type="button" class="layoutBtn" data-layout="p4" aria-label="4 fotos por p√°gina">
              <div class="layoutGrid" style="grid-template-columns:repeat(2,1fr);grid-template-rows:repeat(2,1fr);">
                <span></span><span></span><span></span><span></span>
              </div>
              <div class="layoutLabel">4</div>
              <div class="muted">2√ó2</div>
            </button>
            <button type="button" class="layoutBtn" data-layout="p6" aria-label="6 fotos por p√°gina">
              <div class="layoutGrid" style="grid-template-columns:repeat(2,1fr);grid-template-rows:repeat(3,1fr);">
                <span></span><span></span><span></span><span></span><span></span><span></span>
              </div>
              <div class="layoutLabel">6</div>
              <div class="muted">2√ó3</div>
            </button>
            <button type="button" class="layoutBtn" data-layout="p8" aria-label="8 fotos por p√°gina">
              <div class="layoutGrid" style="grid-template-columns:repeat(2,1fr);grid-template-rows:repeat(4,1fr);">
                <span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span>
              </div>
              <div class="layoutLabel">8</div>
              <div class="muted">2√ó4</div>
            </button>
          </div>
          <div class="muted" style="margin-top:6px">Ajusta tama√±os autom√°ticamente en PDF/DOCX (Express y ZIP).</div>
        </div>
      </div>

      



      <div class="row" style="margin-top:10px;">
<label style="display:flex;align-items:center;gap:10px;margin:0">
          <input type="checkbox" id="onlyDone" />
          <span class="muted">Solo exportar LISTAS</span>
        </label>

        <label style="display:flex;align-items:center;gap:10px;margin:0">
          <span class="muted">Ajuste foto en DOCX</span>
          <select id="docxFit" style="width:auto">
            <option value="stretch">Estirar (deforma)</option>
            <option value="contain">Sin deformar (bordes blancos)</option>
            <option value="cover">Recortar (rellenar)</option>
          </select>
        </label>
      </div>
      <!-- Logo / Compartir (definido solo aqu√≠) -->
      <div class="row" style="margin-top:10px;align-items:center;gap:10px;flex-wrap:wrap">
        <div style="flex:1;min-width:220px">
          <label>Logo (opcional)</label>
          <div class="row" style="gap:10px;margin-top:6px;align-items:center">
            <button class="btn btn-secondary" id="btnCargarLogo" type="button">üñºÔ∏è Cargar logo</button>
            <button class="btn btn-secondary" id="btnQuitarLogo" type="button" style="display:none">üóëÔ∏è Quitar logo</button>

            <select id="logoCorner" style="width:auto">
              <option value="br">Logo: inferior derecha</option>
              <option value="bl">Logo: inferior izquierda</option>
              <option value="tr">Logo: superior derecha</option>
              <option value="tl">Logo: superior izquierda</option>
            </select>

            <img id="logoPreview" alt="Logo"
                 style="height:34px;width:auto;border-radius:10px;border:1px solid var(--border);display:none"/>
          </div>
          <div class="muted" style="margin-top:6px">
            El logo se aplica solo al exportar o compartir. La foto original no se modifica.
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <label style="display:flex;align-items:center;gap:10px;margin:0">
          <input type="checkbox" id="waAddLogo" checked />
          <span class="muted">Compartir (WhatsApp): incluir logo</span>
        </label>

        <label style="display:flex;align-items:center;gap:10px;margin:0">
          <input type="checkbox" id="waAddStamp" />
          <span class="muted">Compartir (WhatsApp): incluir fecha/hora</span>
        </label>
      </div>



      <div class="row" style="margin-top:10px;">
        <label style="display:flex;align-items:center;gap:10px;margin:0">
          <input type="checkbox" id="exportLogo" />
          <span class="muted">En exportaci√≥n: incluir logo (si hay logo cargado)</span>
        </label>

        <label style="display:flex;align-items:center;gap:10px;margin:0">
          <input type="checkbox" id="exportStampDT" />
          <span class="muted">En exportaci√≥n: escribir fecha y hora sobre la foto</span>
        </label>
</div>

      <div class="row" style="margin-top:10px;align-items:flex-end;gap:10px;flex-wrap:wrap">
        <div style="flex:1;min-width:220px">
          <label for="expressFormat">Formato de salida</label>
          <select id="expressFormat" style="width:100%">
            <option value="pdf">PDF</option>
            <option value="docx">Word (.docx)</option>
            <option value="zip">ZIP (reporte)</option>
          </select>
        </div>
        <button class="btn btn-primary" id="btnExpress">‚ö° Exportar</button>
        <div id="zipInfo" class="muted" style="flex-basis:100%"></div>
      </div>

    </div>
      
  </div>


  
</div>

<!-- Bottom sheet: Configuraci√≥n -->
  <div class="sheetBackdrop" id="sheetBackdrop" aria-hidden="true">
    <div class="sheet" id="sheet" role="dialog" aria-modal="true" aria-label="Configuraci√≥n">
      <div class="sheetHandle" id="sheetHandle"></div>
      <div class="sheetHeader">
        <div>
          <div class="sheetTitle">Configuraci√≥n</div>
          <div class="muted">Preferencias del dispositivo</div>
        </div>
        <button class="btn btn-secondary smallBtn" id="btnSheetClose">‚úñ</button>
      </div>

      <div class="sheetBody">
        <div class="sheetRow">
          <div class="sheetRowMain">
            <div class="sheetRowTitle">Tema</div>
            <div class="muted" id="themeLabel">‚Äî</div>
          </div>
          <button class="btn btn-secondary smallBtn" id="btnThemeToggle" title="Cambiar tema">üåô</button>
        </div>

        <div class="sheetRow">
          <div class="sheetRowMain">
            <div class="sheetRowTitle">Acento</div>
            <div class="muted">Color principal de la app</div>
          </div>
          <div class="accentPalette" id="accentPalette"></div>
        </div>

        <div class="sheetRow">
          <div class="sheetRowMain">
            <div class="sheetRowTitle">Actualizar app</div>
            <div class="muted" id="updateLabel">Buscar / instalar actualizaci√≥n</div>
          </div>
          <button class="btn btn-primary smallBtn" id="btnUpdateFromSheet">üîÑ</button>
        </div>

        <button class="btn btn-secondary" id="btnResetCache" style="width:100%">üß∞ Reiniciar cach√© (si se queda pegada)</button>

        <div class="sheetRow">
          <div class="sheetRowMain">
            <div class="sheetRowTitle">Respaldo</div>
            <div class="muted">Crear / restaurar backup (ZIP con fotos)</div>
          </div>
          <div class="row" style="gap:8px;flex-wrap:nowrap">
            <button class="btn btn-secondary smallBtn" id="btnBackupCreate" title="Crear backup">‚¨áÔ∏è</button>
            <button class="btn btn-secondary smallBtn" id="btnBackupRestore" title="Restaurar backup">‚¨ÜÔ∏è</button>
          </div>
        </div>
        <div class="muted" id="backupStatus" style="margin-top:-2px">Consejo: haz backup al final del d√≠a o antes de actualizar.</div>
        <progress id="backupProgress" max="100" value="0" style="width:100%;display:none;margin-top:8px"></progress>

        <div class="sheetRow">
          <div class="sheetRowMain">
            <div class="sheetRowTitle">Eliminar proyecto</div>
            <div class="muted">Borra un proyecto y todas sus fotos/√≠tems del dispositivo</div>
          </div>
          <div class="row" style="gap:8px;flex-wrap:nowrap">
            <select id="deleteProjectSelect" style="min-width:210px;max-width:340px"></select>
            <button class="btn btn-danger smallBtn" id="btnDeleteProject" title="Eliminar proyecto">üóëÔ∏è</button>
          </div>
        </div>

        <div class="sheetRow dangerRow">
          <div class="sheetRowMain">
            <div class="sheetRowTitle">Borrar todo</div>
            <div class="muted">Elimina todas las fotos, descripciones y proyectos guardados en este dispositivo</div>
          </div>
          <button class="btn btn-danger smallBtn" id="btnBorrarTodo" title="Borrar todo">üóëÔ∏è</button>
        </div>

        <div class="sheetRow">
          <div class="sheetRowMain">
            <div class="sheetRowTitle">√çtems del proyecto</div>
            <div class="muted" id="itemsLabel">Cargar listado (Excel) por proyecto</div>
          </div>
          <div class="row" style="gap:8px;flex-wrap:nowrap">
            <button class="btn btn-secondary smallBtn" id="btnItemsTemplate" title="Descargar plantilla">üìÑ</button>
            <button class="btn btn-secondary smallBtn" id="btnItemsUpload" title="Cargar listado">‚¨ÜÔ∏è</button>
            <button class="btn btn-danger smallBtn" id="btnItemsClear" title="Borrar √≠tems del proyecto">üóëÔ∏è</button>
          </div>
        </div>
        <div class="muted" id="itemsStatus" style="margin-top:-2px">‚Äî</div>


      
        <div class="sheetRow">
          <div class="sheetRowMain">
            <div class="sheetRowTitle">Almacenamiento</div>
            <div class="muted" id="storageLabel">‚Äî</div>
          </div>
          <button class="btn btn-secondary smallBtn" id="btnStorageRefresh" title="Actualizar">‚Üª</button>
        </div>
        <div class="storageBar" aria-hidden="true"><div class="storageFill" id="storageFill"></div></div>
        <div class="muted" id="storageHint" style="margin-top:-2px">‚Äî</div>
</div>
    </div>
  </div>


  <!-- Modal -->
  <div class="modal" id="modal">
    <div class="modalCard">
      <div class="modalBody">
        <img id="modalImg" class="modalImg" alt="Foto" />
        <div class="modalSide">
          <div class="modalCloseRow">
            <div>
              <div class="modalTitle" id="modalTitle"></div>
              <div class="muted" id="modalMeta"></div>
            </div>
            <button class="btn btn-secondary smallBtn" id="btnModalClose">‚úñ</button>
          </div>

          <div>
            <label>√çtem (opcional)</label>
            <input type="text" id="modalItem" list="datalistItems" placeholder="C√≥digo de √≠tem‚Ä¶" />
            <div class="muted" id="modalItemHint" style="margin-top:6px">‚Äî</div>
          </div>

          <div>
  <label style="display:flex;align-items:center;justify-content:space-between;gap:10px">
    <span>Descripci√≥n</span>
    <button class="btn btn-secondary smallBtn" id="btnModalDictate" title="Dictar (voz)">üéôÔ∏è</button>
  </label>
  <textarea id="modalDesc" placeholder="Descripci√≥n..."></textarea>
  <div class="muted" id="dictateStatus" style="margin-top:6px">‚Äî</div>
</div>

          <div class="row">
            <button class="btn btn-secondary smallBtn" id="btnModalDone">‚úÖ Listo</button>
            <button class="btn btn-secondary smallBtn" id="btnModalShare">üì§ WhatsApp</button>
            <button class="btn btn-danger smallBtn" id="btnModalDelete">üóëÔ∏è</button>
          </div>

          <div class="muted">
            WhatsApp: se comparte <b>solo la imagen</b>. TXT/Excel/DOCX van dentro del ZIP.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal: Proyecto (Logi2) -->
  <div class="modal" id="projModal" aria-hidden="true">
    <div class="modalCard projModalCard">
      <div class="modalBody" style="grid-template-columns:1fr">
        <div class="modalSide">
          <div class="modalCloseRow">
            <div>
              <div class="modalTitle" id="projModalTitle">Proyecto</div>
              <div class="muted" id="projModalMeta">‚Äî</div>
            </div>
            <button class="btn btn-secondary smallBtn" id="btnProjModalClose">‚úñ</button>
          </div>

          <div>
            <label>Nombre del proyecto</label>
            <input type="text" id="projNameInput" placeholder="Ej: Contrato 558 de 2025 ¬∑ Mejoramiento b√≥vedas" />
            <div class="muted" style="margin-top:6px">Tip: usa nombres profesionales. Puedes renombrar cuando quieras.</div>
          </div>

          <div class="row" style="justify-content:flex-end">
            <button class="btn btn-secondary" id="btnProjCancel">Cancelar</button>
            <button class="btn btn-primary" id="btnProjSave">Guardar</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Datalist: √çtems del proyecto -->
  <datalist id="datalistItems"></datalist>


  <div class="modal" id="backupScopeModal" aria-hidden="true">
    <div class="modalCard" style="width:min(620px, 96vw)">
      <div class="modalSide" style="padding:14px;display:grid;gap:12px">
        <div class="modalCloseRow">
          <div>
            <div class="modalTitle">Exportar backup</div>
            <div class="muted">Escoge qu√© proyectos incluir en el ZIP.</div>
          </div>
          <button class="btn btn-secondary smallBtn" id="btnBackupScopeClose">‚úñ</button>
        </div>

        <div class="row" style="gap:8px;flex-wrap:wrap">
          <button class="btn btn-primary" id="btnBackupScopeCurrent">Proyecto actual</button>
          <button class="btn btn-secondary" id="btnBackupScopeAll">Todos</button>
          <button class="btn btn-secondary" id="btnBackupScopePick">Seleccionar‚Ä¶</button>
        </div>

        <div id="backupPickWrap" style="display:none">
          <div class="muted" style="margin:6px 0 8px">Selecciona uno o varios proyectos:</div>
          <div id="backupPickList" style="display:grid;gap:8px;max-height:38vh;overflow:auto;border:1px solid var(--border);border-radius:12px;padding:10px;background:var(--card);"></div>
          <div class="row" style="justify-content:flex-end;gap:8px;margin-top:10px">
            <button class="btn btn-secondary" id="btnBackupPickCancel">Cancelar</button>
            <button class="btn btn-primary" id="btnBackupPickConfirm">Exportar selecci√≥n</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
function $(id){ return document.getElementById(id); }


/* ===========================
   üéôÔ∏è Dictado por voz (Web Speech API)
   - Funciona en Chrome/Android (webkitSpeechRecognition).
   - Requiere HTTPS para pedir micr√≥fono.
   - Si no est√° disponible, usa el mic del teclado.
=========================== */
const _SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition || null;

const dictation = {
  rec: null,
  active: false,
  btn: null,
  target: null,
  baseText: "",
  finalText: ""
};

function setDictateStatus(msg){
  const el = $("dictateStatus");
  if (el) el.textContent = msg || "‚Äî";
}

function stopDictation(){
  try { dictation.rec && dictation.rec.stop(); } catch {}
  dictation.active = false;
  dictation.rec = null;

  if (dictation.btn){
    dictation.btn.textContent = "üéôÔ∏è";
    dictation.btn.classList.remove("btn-danger");
    dictation.btn.classList.add("btn-secondary");
  }
  setDictateStatus("‚Äî");
  dictation.btn = null;
  dictation.target = null;
  dictation.baseText = "";
  dictation.finalText = "";
}

function startDictation(targetEl, btnEl){
  if (!_SpeechRec){
    alert("Dictado por voz no disponible en este navegador.\n\nTip: usa el micr√≥fono del teclado para dictar.");
    return;
  }
  if (!targetEl) return;

  // Si ya estaba dictando, detener
  if (dictation.active) {
    stopDictation();
    return;
  }

  const rec = new _SpeechRec();
  rec.lang = "es-CO";
  rec.continuous = false;
  rec.interimResults = true;
  rec.maxAlternatives = 1;

  dictation.rec = rec;
  dictation.active = true;
  dictation.btn = btnEl || null;
  dictation.target = targetEl;

  dictation.baseText = (targetEl.value || "").trimEnd();
  dictation.finalText = "";

  if (dictation.btn){
    dictation.btn.textContent = "‚èπÔ∏è";
    dictation.btn.classList.remove("btn-secondary");
    dictation.btn.classList.add("btn-danger");
  }
  setDictateStatus("üéôÔ∏è Dictando‚Ä¶");

  rec.onresult = (event) => {
    // Reconstruir transcript completo para evitar duplicados (en algunos navegadores resultIndex se reinicia).
    const finals = [];
    const interims = [];

    for (let i = 0; i < event.results.length; i++){
      const res = event.results[i];
      const t = (res[0]?.transcript || "").trim();
      if (!t) continue;
      if (res.isFinal) finals.push(t);
      else interims.push(t);
    }

    const base = dictation.baseText ? (dictation.baseText.trimEnd() + " " ) : "";
    const composed = (base + [...finals, ...interims].join(" "))
      .replace(/\s+/g, " " )
      .trim();

    targetEl.value = composed;
    try { targetEl.setSelectionRange(targetEl.value.length, targetEl.value.length); } catch {}

    // disparar persistencia (tu app guarda en oninput)
    try { targetEl.dispatchEvent(new Event("input", { bubbles: true })); } catch {}
  };

  rec.onerror = (e) => {
    setDictateStatus("‚ö†Ô∏è Dictado detenido (" + (e?.error || "error") + ")");
    stopDictation();
  };

  rec.onend = () => {
    if (dictation.active) stopDictation();
  };

  try { rec.start(); }
  catch (err){
    stopDictation();
    alert("No pude iniciar el dictado.\n\nDetalle: " + (err?.message || err));
  }
}

// Detener dictado si la app se oculta
document.addEventListener("visibilitychange", () => {
  if (document.hidden && dictation.active) stopDictation();
});
window.addEventListener("beforeunload", () => {
  if (dictation.active) stopDictation();
});

/* ===========================
   üé® Tema (por dispositivo)
=========================== */
const THEME_KEY = "logi_theme";

function setMetaThemeColor(color){
  const meta = document.querySelector('meta[name="theme-color"]');
  if (meta) meta.setAttribute("content", color);
}

function applyTheme(theme){
  document.documentElement.dataset.theme = theme;
  localStorage.setItem(THEME_KEY, theme);
  setMetaThemeColor(theme === "light" ? "#f5f7fb" : "#0b1220");
}

function syncThemeUI(){
  const theme = document.documentElement.dataset.theme || "dark";
  const label = $("themeLabel");
  if (label) label.textContent = (theme === "light") ? "Claro" : "Oscuro";
  const btn = $("btnThemeToggle");
  if (btn) btn.textContent = (theme === "light") ? "‚òÄÔ∏è" : "üåô";
}

function toggleTheme(){
  const cur = localStorage.getItem(THEME_KEY) || "dark";
  applyTheme(cur === "dark" ? "light" : "dark");
  syncThemeUI();
}

function initTheme(){
  const saved = localStorage.getItem(THEME_KEY) || "dark";
  applyTheme(saved);
  syncThemeUI();
}


/* ===========================
   Service Worker (PWA) + Update UI
=========================== */
let waitingSW = null;

function showUpdateUI(){
  $("updateBar").classList.add("show");
  const sbtn = $("btnSettings");
  if (sbtn) sbtn.classList.add("hasUpdate");
  const ul = $("updateLabel");
  if (ul) ul.textContent = "‚úÖ Hay una actualizaci√≥n lista";
}

async function triggerSWUpdate(){
  try{
    if (waitingSW){
      waitingSW.postMessage({ type: "SKIP_WAITING" });
    } else {
      const reg = await navigator.serviceWorker.getRegistration();
      if (reg) await reg.update();
    }
  }catch{}
}

if ("serviceWorker" in navigator) {
  window.addEventListener("load", async () => {
    try{
      const reg = await navigator.serviceWorker.register("./sw.js");

      if (reg.waiting){
        waitingSW = reg.waiting;
        showUpdateUI();
      }

      reg.addEventListener("updatefound", () => {
        const newSW = reg.installing;
        if (!newSW) return;

        newSW.addEventListener("statechange", () => {
          if (newSW.state === "installed" && navigator.serviceWorker.controller){
            waitingSW = reg.waiting;
            showUpdateUI();
          }
        });
      });

      navigator.serviceWorker.addEventListener("controllerchange", () => {
        window.location.reload();
      });

    }catch(e){}
  });
}

$("btnUpdateNow").onclick = triggerSWUpdate;

/* ===========================
   ‚öôÔ∏è Bottom sheet (config)
=========================== */

async function updateStorageUI(){
  const label = $("storageLabel");
  const fill  = $("storageFill");
  const hint  = $("storageHint");
  if (!label) return;

  // Estimaci√≥n de cuota (depende del navegador/dispositivo)
  if (!(navigator.storage && navigator.storage.estimate)){
    label.textContent = "No disponible en este dispositivo.";
    if (hint) hint.textContent = "‚Äî";
    if (fill) fill.style.width = "0%";
    return;
  }

  try{
    const { usage, quota } = await navigator.storage.estimate();
    if (!quota){
      label.textContent = "No disponible en este dispositivo.";
      if (hint) hint.textContent = "‚Äî";
      if (fill) fill.style.width = "0%";
      return;
    }

    const usedMB  = (usage || 0) / (1024*1024);
    const quotaMB = quota / (1024*1024);
    const pct = quota ? Math.min(100, Math.max(0, (usage / quota) * 100)) : 0;

    label.textContent = `Usado ${usedMB.toFixed(1)} MB / ${quotaMB.toFixed(1)} MB (${pct.toFixed(0)}%)`;
    if (fill) fill.style.width = pct.toFixed(1) + "%";

    let msg = "Todo bien.";
    if (pct >= 95) msg = "‚ö†Ô∏è Muy lleno. Recomendado: hacer backup y borrar fotos viejas.";
    else if (pct >= 85) msg = "‚ö†Ô∏è Cerca del l√≠mite. Recomendado: hacer backup.";
    else if (pct >= 70) msg = "Sugerencia: haz backup peri√≥dicamente para evitar quedarte sin espacio.";

    if (hint) hint.textContent = msg;
  }catch(e){
    label.textContent = "No se pudo leer el almacenamiento.";
    if (hint) hint.textContent = "‚Äî";
    if (fill) fill.style.width = "0%";
  }
}

function openSheet(){
  $("sheetBackdrop").classList.add("open");
  $("sheet").classList.add("open");
  $("sheetBackdrop").setAttribute("aria-hidden","false");
  // Si hab√≠a puntico de update, lo dejamos (es info √∫til). No lo quitamos.
  syncThemeUI();
  syncAccentUI();
  syncUpdateLabel();
  updateStorageUI();
}
function closeSheet(){
  $("sheet").classList.remove("open");
  // esperar transici√≥n
  setTimeout(() => {
    $("sheetBackdrop").classList.remove("open");
    $("sheetBackdrop").setAttribute("aria-hidden","true");
  }, 220);
}

$("btnSettings").onclick = openSheet;
$("btnSheetClose").onclick = closeSheet;
$("btnStorageRefresh").onclick = updateStorageUI;

$("sheetBackdrop").addEventListener("click", (e)=>{ if (e.target.id === "sheetBackdrop") closeSheet(); });

/* Gestos: arrastrar hacia abajo */
(function sheetGestures(){
  const sheet = $("sheet");
  let startY = 0;
  let curY = 0;
  let dragging = false;

  function onStart(e){
    const t = e.touches ? e.touches[0] : e;
    startY = t.clientY;
    curY = 0;
    dragging = true;
    sheet.style.transition = "none";
  }
  function onMove(e){
    if (!dragging) return;
    const t = e.touches ? e.touches[0] : e;
    const dy = t.clientY - startY;
    curY = Math.max(0, dy);
    sheet.style.transform = `translateY(${curY}px)`;
  }
  function onEnd(){
    if (!dragging) return;
    dragging = false;
    sheet.style.transition = "transform .22s ease";
    if (curY > 120){
      sheet.style.transform = "translateY(110%)";
      closeSheet();
    } else {
      sheet.style.transform = "translateY(0)";
    }
  }

  $("sheetHandle").addEventListener("touchstart", onStart, { passive:true });
  $("sheetHandle").addEventListener("touchmove", onMove, { passive:true });
  $("sheetHandle").addEventListener("touchend", onEnd);

  sheet.addEventListener("touchstart", (e)=>{
    // Solo permitir gesto si el scroll est√° arriba (evita pelear con el scroll del contenido)
    if (sheet.scrollTop && sheet.scrollTop > 0) return;
    if (e.target.closest(".sheetBody")) return;
    onStart(e);
  }, { passive:true });
  sheet.addEventListener("touchmove", onMove, { passive:true });
  sheet.addEventListener("touchend", onEnd);
})();

/* ===========================
   üé® Acento (por dispositivo)
=========================== */
const ACCENT_KEY = "logi_accent";

const PROJECT_KEY = "logi_project";
const TEMPLATE_KEY = "logi_template";

const ACCENTS = [
  { key:"blue",   name:"Azul",   hex:"#3b82f6", hex2:"#60a5fa", rgb:"59,130,246" },
  { key:"teal",   name:"Teal",   hex:"#14b8a6", hex2:"#2dd4bf", rgb:"20,184,166" },
  { key:"green",  name:"Verde",  hex:"#22c55e", hex2:"#4ade80", rgb:"34,197,94" },
  { key:"purple", name:"Morado", hex:"#8b5cf6", hex2:"#a78bfa", rgb:"139,92,246" },
  { key:"orange", name:"Naranja",hex:"#f97316", hex2:"#fb923c", rgb:"249,115,22" },
  { key:"rose",   name:"Rosa",   hex:"#f43f5e", hex2:"#fb7185", rgb:"244,63,94" }
];

function applyAccent(key){
  const chosen = ACCENTS.find(a => a.key === key) || ACCENTS[0];
  localStorage.setItem(ACCENT_KEY, chosen.key);
  document.documentElement.style.setProperty("--accent", chosen.hex);
  document.documentElement.style.setProperty("--accent2", chosen.hex2);
  document.documentElement.style.setProperty("--accent-rgb", chosen.rgb);
  syncAccentUI();
}

function syncAccentUI(){
  const key = localStorage.getItem(ACCENT_KEY) || "blue";
  const dots = document.querySelectorAll(".accentDot");
  dots.forEach(d => d.classList.toggle("active", d.dataset.accent === key));
}

function initAccent(){
  const key = localStorage.getItem(ACCENT_KEY) || "blue";
  const pal = $("accentPalette");
  if (pal){
    pal.innerHTML = "";
    for (const a of ACCENTS){
      const dot = document.createElement("div");
      dot.className = "accentDot";
      dot.dataset.accent = a.key;
      dot.title = a.name;
      dot.style.background = a.hex;
      dot.onclick = () => applyAccent(a.key);
      pal.appendChild(dot);
    }
  }
  applyAccent(key);
}

/* ===========================
   Actualizar app (config)
=========================== */
function syncUpdateLabel(){
  const ul = $("updateLabel");
  if (!ul) return;
  if (waitingSW) ul.textContent = "‚úÖ Hay una actualizaci√≥n lista";
  else ul.textContent = "Buscar / instalar actualizaci√≥n";
}
$("btnUpdateFromSheet").onclick = async () => {
  await triggerSWUpdate();
  // Feedback suave
  if (!waitingSW) $("updateLabel").textContent = "üîé Revisando‚Ä¶";
  setTimeout(syncUpdateLabel, 1200);
};

$("btnThemeToggle").onclick = toggleTheme;

/* ===========================
   üß∞ Reiniciar cach√© (NO borra fotos)
=========================== */
async function repairApp(){
  try{
    if ("serviceWorker" in navigator){
      const regs = await navigator.serviceWorker.getRegistrations();
      await Promise.all(regs.map(r => r.unregister()));
    }
    if (window.caches){
      const keys = await caches.keys();
      await Promise.all(keys.map(k => caches.delete(k)));
    }
  }catch{}
  const base = location.origin + location.pathname;
  location.replace(base + "?r=" + Date.now());
}
$("btnResetCache").onclick = repairApp;
/* ===========================
   üíæ Backup / Restore (ZIP) ‚Äî NO requiere extraer manualmente
   - Incluye fotos + metadata + (opcional) logo + settings
   - Restore "mezcla": no borra lo existente, y evita duplicados por id
=========================== */
function isoNowSafe(){
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  const hh = String(d.getHours()).padStart(2,"0");
  const mm = String(d.getMinutes()).padStart(2,"0");
  return `${y}${m}${dd}_${hh}${mm}`;
}

async function dataUrlToBlob(dataUrl){
  const res = await fetch(dataUrl);
  return await res.blob();
}

function extFromMime(m){
  if (!m) return "bin";
  if (m.includes("jpeg") || m.includes("jpg")) return "jpg";
  if (m.includes("png")) return "png";
  if (m.includes("webp")) return "webp";
  return "bin";
}

async function pickBackupScope(){
  return new Promise((resolve) => {
    const modal = $("backupScopeModal");
    const btnClose = $("btnBackupScopeClose");
    const btnCurrent = $("btnBackupScopeCurrent");
    const btnAll = $("btnBackupScopeAll");
    const btnPick = $("btnBackupScopePick");
    const wrap = $("backupPickWrap");
    const list = $("backupPickList");
    const btnCancel = $("btnBackupPickCancel");
    const btnConfirm = $("btnBackupPickConfirm");

    const { projects, activeId } = ensureProjects();

    const close = (res) => {
      modal.classList.remove("open");
      modal.setAttribute("aria-hidden","true");
      wrap.style.display = "none";
      list.innerHTML = "";
      // limpieza handlers (evita acumulaci√≥n)
      btnClose.onclick = null;
      btnCurrent.onclick = null;
      btnAll.onclick = null;
      btnPick.onclick = null;
      btnCancel.onclick = null;
      btnConfirm.onclick = null;
      resolve(res || null);
    };

    // abrir
    modal.classList.add("open");
    modal.setAttribute("aria-hidden","false");

    btnClose.onclick = () => close(null);

    btnCurrent.onclick = () => close({ mode:"current", projectIds:[activeId] });
    btnAll.onclick = () => close({ mode:"all", projectIds: projects.map(p => p.id) });

    btnPick.onclick = () => {
      wrap.style.display = "block";
      list.innerHTML = "";
      for (const p of projects){
        const row = document.createElement("label");
        row.style.display = "flex";
        row.style.gap = "10px";
        row.style.alignItems = "center";
        row.style.padding = "8px 8px";
        row.style.border = "1px solid var(--border)";
        row.style.borderRadius = "12px";
        row.style.background = "var(--card2)";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = p.id;
        cb.style.transform = "scale(1.05)";
        const txt = document.createElement("div");
        const t1 = document.createElement("div");
        t1.style.fontWeight = "900";
        t1.textContent = p.name;
        const t2 = document.createElement("div");
        t2.className = "muted";
        t2.style.fontSize = ".82rem";
        t2.textContent = p.id;
        txt.appendChild(t1);
        txt.appendChild(t2);
        row.appendChild(cb);
        row.appendChild(txt);
        list.appendChild(row);
      }
    };

    btnCancel.onclick = () => close(null);

    btnConfirm.onclick = () => {
      const ids = [...list.querySelectorAll("input[type=checkbox]")].filter(x => x.checked).map(x => x.value);
      if (!ids.length){
        alert("Selecciona al menos un proyecto.");
        return;
      }
      close({ mode:"selected", projectIds: ids });
    };

    // cerrar con ESC
    const onKey = (ev) => {
      if (ev.key === "Escape"){
        document.removeEventListener("keydown", onKey);
        close(null);
      }
    };
    document.addEventListener("keydown", onKey, { once:true });
  });
}

async function createBackupZip(scope){
  if (!window.JSZip){
    alert("JSZip no est√° disponible. Abre la app con internet (una vez) y prueba de nuevo.");
    return;
  }

  const prog = $("backupProgress");
  if (prog){ prog.style.display = "none"; prog.value = 0; prog.max = 100; }

  $("backupStatus").textContent = "Preparando backup‚Ä¶";

  const { projects, activeId } = ensureProjects();
  const firstId = projects[0]?.id || activeId;

  const projectIds = (scope && Array.isArray(scope.projectIds) ? scope.projectIds : []);
  const allowed = new Set(projectIds);

  if (!projectIds.length){
    $("backupStatus").textContent = "‚Äî";
    return;
  }

  // fotos
  const allItems = await dbGetAll();
  const normPid = (it) => it.projectId ? it.projectId : firstId;
  const items = allItems.filter(it => allowed.has(normPid(it)));

  // cat√°logo (por proyecto)
  const catalogRows = [];
  for (const pid of projectIds){
    try{
      const rows = await catGetByProject(pid);
      for (const r of (rows || [])) catalogRows.push(r);
    }catch{}
  }

  const settings = {
    theme: localStorage.getItem(THEME_KEY) || "dark",
    accent: localStorage.getItem(ACCENT_KEY) || "blue",
    project: localStorage.getItem(PROJECT_KEY) || "",
    template: localStorage.getItem(TEMPLATE_KEY) || "",
    docxFit: localStorage.getItem("logi_docx_fit") || "stretch",
    logoEnabled: localStorage.getItem("logi_logo_enabled") === "1",
    logoCorner: localStorage.getItem("logi_logo_corner") || "br",
  };

  const backup = {
    schemaVersion: 2,
    app: "Logi2",
    createdAt: new Date().toISOString(),
    projects: projects.filter(p => allowed.has(p.id)),
    activeProjectId: activeId,
    settings,
    catalog: catalogRows.map(r => ({
      projectId: r.projectId,
      item: r.item,
      descripcion: r.descripcion || ""
    })),
    items: items.map(it => ({
      id: it.id,
      fecha: it.fecha || "",
      proyecto: it.proyecto || "",
      descripcion: it.descripcion || "",
      done: !!it.done,
      mime: it.mime || "image/jpeg",
      createdAt: it.createdAt || Date.now(),
      hasLogo: !!it.hasLogo,
      projectId: normPid(it),
      itemCode: it.itemCode || "",
      itemDesc: it.itemDesc || ""
    }))
  };

  const zip = new JSZip();
  zip.file("backup.json", JSON.stringify(backup));
  const photos = zip.folder("photos");

  let i = 0;
  for (const it of items){
    i++;
    if (prog){ prog.style.display = "block"; prog.max = items.length; prog.value = i; }
    $("backupStatus").textContent = `Agregando fotos‚Ä¶ (${i}/${items.length})`;
    const ext = extFromMime(it.mime || "image/jpeg");
    photos.file(`${it.id}.${ext}`, it.blob);
  }

  // logo (si existe)
  const logoData = localStorage.getItem("logi_logo_dataurl");
  if (logoData){
    try{
      const lb = await dataUrlToBlob(logoData);
      const lfolder = zip.folder("logo");
      const lExt = extFromMime(lb.type || "image/png");
      lfolder.file(`logo.${lExt}`, lb);
    }catch{}
  }

  $("backupStatus").textContent = "Comprimiendo ZIP‚Ä¶";
  const outBlob = await zip.generateAsync({ type: "blob" }, (meta) => {
    $("backupStatus").textContent = `Comprimiendo‚Ä¶ ${Math.floor(meta.percent)}%`;
  });

  const name = `logi-backup-${isoNowSafe()}.zip`;
  const url = URL.createObjectURL(outBlob);
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  if (prog){ prog.style.display = "none"; prog.value = 0; prog.max = 100; }

  $("backupStatus").textContent = `Backup listo ‚úÖ (${items.length} fotos, ${projectIds.length} proyecto(s))`;
  setTimeout(() => { $("backupStatus").textContent = "Consejo: haz backup al final del d√≠a o antes de actualizar."; }, 2500);
}


async function restoreBackupZip(file){
  if (!window.JSZip){
    alert("JSZip no est√° disponible. Abre la app con internet (una vez) y prueba de nuevo.");
    return;
  }

  const prog = $("backupProgress");
  if (prog){ prog.style.display = "block"; prog.value = 0; prog.max = 100; }

  $("backupStatus").textContent = "Leyendo ZIP‚Ä¶";

  const zip = await JSZip.loadAsync(file);
  const bj = zip.file("backup.json");
  if (!bj){
    alert("Ese ZIP no parece un backup de Logi (falta backup.json).");
    if (prog){ prog.style.display = "none"; }
    return;
  }

  const jsonText = await bj.async("string");
  let backup;
  try{
    backup = JSON.parse(jsonText);
  }catch{
    alert("El backup.json est√° corrupto o no es v√°lido.");
    if (prog){ prog.style.display = "none"; }
    return;
  }

  const importSettings = confirm("¬øTambi√©n quieres importar CONFIGURACI√ìN (tema/acento/proyecto/logo)?

Si dices Cancelar, solo importo las fotos.");

  // ¬øRespetar proyectos?
  const hasProjects = Array.isArray(backup.projects) && backup.projects.length;
  let keepProjects = !!hasProjects;
  if (hasProjects && backup.projects.length > 1){
    keepProjects = confirm("Este backup trae varios proyectos.

Aceptar: RESTAURAR respetando proyectos.
Cancelar: importar TODO al proyecto actual.");
  }

  // Preparar mapeo de proyectos (evitar choques de IDs)
  let projIdMap = {};
  if (hasProjects && keepProjects){
    const local = ensureProjects();
    const existingIds = new Set(local.projects.map(p => p.id));
    const merged = [...local.projects];

    for (const p of backup.projects){
      let newId = p.id;
      if (existingIds.has(newId)){
        newId = genPid();
      }
      projIdMap[p.id] = newId;
      if (!existingIds.has(newId)){
        merged.push({
          id: newId,
          name: (p && p.name) ? p.name : "Proyecto importado",
          createdAt: Date.now()
        });
        existingIds.add(newId);
      }
    }
    saveProjects(merged);
    refreshProjectUI();
  }

  const { projects, activeId } = ensureProjects();
  const destProjectId = activeId;
  const firstId = projects[0]?.id || destProjectId;

  // mapa de existentes (mezclar)
  const existing = new Set(cache.map(x => x.id));
  let added = 0;
  let skipped = 0;

  // intentar importar logo primero (si se pidi√≥)
  if (importSettings){
    try{
      const logoFolder = zip.folder("logo");
      if (logoFolder){
        const candidates = Object.keys(logoFolder.files || {}).filter(p => p.startsWith("logo/") && !logoFolder.files[p].dir);
        if (candidates.length){
          const lf = zip.file(candidates[0]);
          if (lf){
            const lb = await lf.async("blob");
            const fr = new FileReader();
            const dataUrl = await new Promise((res, rej) => {
              fr.onload = () => res(fr.result);
              fr.onerror = () => rej(fr.error);
              fr.readAsDataURL(lb);
            });
            localStorage.setItem("logi_logo_dataurl", dataUrl);
            try{ setLogoPreview(dataUrl); }catch{}
          }
        }
      }
    }catch{}
  }

  const itemsArr = Array.isArray(backup.items) ? backup.items : [];
  const total = itemsArr.length;
  if (prog){ prog.max = Math.max(1, total); prog.value = 0; }

  for (let idx=0; idx<total; idx++){
    const meta = itemsArr[idx];
    const id = meta.id;

    if (existing.has(id)){
      skipped++;
      if (prog) prog.value = idx+1;
      continue;
    }

    // localizar archivo de foto por id (puede tener ext distinta)
    const possible = [`photos/${id}.jpg`, `photos/${id}.jpeg`, `photos/${id}.png`, `photos/${id}.webp`, `photos/${id}.gif`];
    let blob = null;

    for (const p of possible){
      const zf = zip.file(p);
      if (zf){
        blob = await zf.async("blob");
        break;
      }
    }

    // compat legacy: si no est√° por rutas, intentar cualquier archivo que empiece por photos/id.
    if (!blob){
      const all = Object.keys(zip.files || {});
      const found = all.find(x => x.startsWith(`photos/${id}.`) && !zip.files[x].dir);
      if (found){
        blob = await zip.file(found).async("blob");
      }
    }

    if (!blob){
      // sin foto, omitimos
      skipped++;
      if (prog) prog.value = idx+1;
      continue;
    }

    const srcPid = meta.projectId || backup.activeProjectId || (backup.projects && backup.projects[0] && backup.projects[0].id) || "";
    let finalPid = destProjectId;

    if (hasProjects && keepProjects){
      finalPid = projIdMap[srcPid] || projIdMap[(backup.projects && backup.projects[0] && backup.projects[0].id) || ""] || destProjectId;
    } else {
      finalPid = destProjectId;
    }

    const it = {
      id,
      fecha: meta.fecha || "",
      proyecto: meta.proyecto || "",
      descripcion: meta.descripcion || "",
      done: !!meta.done,
      blob,
      mime: meta.mime || blob.type || "image/jpeg",
      createdAt: meta.createdAt || Date.now(),
      hasLogo: !!meta.hasLogo,
      projectId: finalPid || firstId,
      itemCode: meta.itemCode || "",
      itemDesc: meta.itemDesc || ""
    };

    await dbPut(it);
    cache.push(it);
    existing.add(id);
    added++;

    if (prog) prog.value = idx+1;
    if ((idx % 6) === 0){
      $("backupStatus").textContent = `Importando‚Ä¶ (${idx+1}/${total}) ¬∑ +${added} / omitidas ${skipped}`;
    }
  }

  // importar cat√°logo si existe
  if (Array.isArray(backup.catalog) && backup.catalog.length){
    try{
      $("backupStatus").textContent = "Importando cat√°logo de √≠tems‚Ä¶";
      const batch = [];
      for (const r of backup.catalog){
        const srcPid = r.projectId || backup.activeProjectId || "";
        let pid = destProjectId;
        if (hasProjects && keepProjects){
          pid = projIdMap[srcPid] || destProjectId;
        }
        const item = String(r.item || "").trim();
        if (!item) continue;
        batch.push({
          key: `${pid}::${item}`,
          projectId: pid,
          item,
          descripcion: String(r.descripcion || "").trim(),
          createdAt: Date.now()
        });
      }
      // chunk para no reventar transacciones gigantes
      const CH = 600;
      for (let i=0; i<batch.length; i+=CH){
        await catPutMany(batch.slice(i, i+CH));
      }
    }catch(e){
      console.error(e);
    }
  }

  // settings (si se pidi√≥)
  if (importSettings && backup.settings){
    try{
      if (backup.settings.theme) applyTheme(backup.settings.theme);
      if (backup.settings.accent) applyAccent(backup.settings.accent);
      if (typeof backup.settings.project === "string") setProjectDefault(backup.settings.project);
      if (backup.settings.template) setTemplateId(backup.settings.template);
      if (backup.settings.docxFit) localStorage.setItem("logi_docx_fit", backup.settings.docxFit);
      if (typeof backup.settings.logoEnabled === "boolean") localStorage.setItem("logi_logo_enabled", backup.settings.logoEnabled ? "1":"0");
      if (backup.settings.logoCorner) localStorage.setItem("logi_logo_corner", backup.settings.logoCorner);
    }catch{}
  }

  if (prog){ prog.style.display = "none"; prog.value = 0; prog.max = 100; }

  $("backupStatus").textContent = `Restaurado ‚úÖ (+${added} fotos, omitidas ${skipped})`;
  setTimeout(() => { $("backupStatus").textContent = "Consejo: haz backup al final del d√≠a o antes de actualizar."; }, 3500);

  // refrescar UI/cach√©
  try{
    await loadCacheForActiveProject();
    await loadCatalogForActiveProject();
    refreshProjectUI();
    render();
  }catch{}
}


$("btnBackupCreate").onclick = async () => {
  // Cerrar panel para que el modal no quede detr√°s
  try{ closeSheet(); }catch{}
  const scope = await pickBackupScope();
  if (!scope) return;
  try { await createBackupZip(scope); }
  catch (e){
    console.error(e);
    alert("No pude crear el backup. Si es la primera vez, abre la app con internet (una vez) y reintenta.");
    $("backupStatus").textContent = "‚Äî";
  }
};

$("btnBackupRestore").onclick = () => {
  $("backupInput").value = "";
  $("backupInput").click();
};

$("backupInput").onchange = async () => {
  const file = $("backupInput").files?.[0];
  if (!file) return;
  const ok = confirm("Vas a RESTAURAR un backup.\n\n‚Ä¢ No se borrar√° nada.\n‚Ä¢ Se mezclar√°n fotos nuevas.\n\n¬øContinuar?");
  if (!ok) { $("backupInput").value=""; return; }

  try{
    await restoreBackupZip(file);
  }catch(e){
    alert("No pude restaurar ese ZIP. ¬øSeguro es un backup generado por Logi?");
    $("backupStatus").textContent = "‚Äî";
  }finally{
    $("backupInput").value = "";
    updateStorageUI();
  }
};

/* ===========================
   üìã √çtems: plantilla + carga (por proyecto)
=========================== */
$("btnItemsTemplate").onclick = () => {
  try{ downloadTemplateItems(); }catch{}
};

$("btnItemsUpload").onclick = () => {
  $("itemsInput").value = "";
  $("itemsInput").click();
};

$("btnItemsClear").onclick = async () => {
  const p = getActiveProject();
  if (!p) return;
  const ok = confirm(`Vas a borrar el LISTADO de √≠tems del proyecto:\n\n${p.name}\n\n(Esto NO borra fotos)\n\n¬øContinuar?`);
  if (!ok) return;
  try{
    await catClearProject(p.id);
    await loadCatalogForActiveProject();
    render();
  }catch{
    alert("No pude borrar el listado. Intenta de nuevo.");
  }
};

$("itemsInput").onchange = async () => {
  const file = $("itemsInput").files?.[0];
  if (!file) return;

  $("itemsStatus").textContent = "Importando‚Ä¶";
  try{
    const res = await importItemsFile(file);
    $("itemsStatus").textContent = `Importado ‚úÖ (le√≠dos: ${res.total}, cargados: ${res.added}, omitidos: ${res.skipped})`;
    setTimeout(()=> refreshCatalogStatus(), 2200);
  }catch(e){
    console.error(e);
    const ext = (file.name || "").toLowerCase();
  let wb;

  // CSV: lectura directa
  if (ext.endsWith(".csv")){
    const text = await file.text();
    wb = XLSX.read(text, { type:"string" });
  } else {
    // XLSX: lectura robusta (Android/PWA puede fallar con ArrayBuffer directo)
    const ab = await file.arrayBuffer();

    // Si el archivo no parece ZIP (xlsx) a veces es una p√°gina HTML descargada con nombre .xlsx
    const sig = String.fromCharCode.apply(null, Array.from(new Uint8Array(ab.slice(0,2))));
    // "PK" => zip
    if (sig !== "PK"){
      throw new Error("El archivo no parece un .xlsx v√°lido (firma distinta a PK). Re-descarga la plantilla y vuelve a intentar.");
    }

    try{
      const u8 = new Uint8Array(ab);
      wb = XLSX.read(u8, { type:"array" });
    }catch(err1){
      // Fallback: lectura binaria con FileReader
      const bin = await new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () => reject(fr.error || new Error("No pude leer el archivo"));
        fr.readAsBinaryString(file);
      });
      wb = XLSX.read(bin, { type:"binary" });
    }
  }

  const sheetName = 
    refreshCatalogStatus();
  }finally{
    $("itemsInput").value = "";
  }
};


/* ===========================
   IndexedDB
=========================== */
const DB_NAME = "logi2_db_v1";
const DB_VERSION = 2;

const DB_STORE = "items";          // fotos (registros)
const DB_STORE_CATALOG = "catalog"; // listado de √≠tems por proyecto

function openDB(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);

    req.onupgradeneeded = (ev) => {
      const db = req.result;

      // Store fotos (legacy)
      if (!db.objectStoreNames.contains(DB_STORE)){
        const store = db.createObjectStore(DB_STORE, { keyPath: "id" });
        store.createIndex("byDate", "fecha");
        store.createIndex("byCreated", "createdAt");
      } else {
        // Asegurar √≠ndices (por si el usuario viene de una versi√≥n rara)
        const tx = req.transaction;
        const store = tx.objectStore(DB_STORE);
        if (!store.indexNames.contains("byDate")) store.createIndex("byDate", "fecha");
        if (!store.indexNames.contains("byCreated")) store.createIndex("byCreated", "createdAt");
      }

      // Store cat√°logo √≠tems (nuevo)
      if (!db.objectStoreNames.contains(DB_STORE_CATALOG)){
        const cat = db.createObjectStore(DB_STORE_CATALOG, { keyPath: "key" });
        cat.createIndex("byProject", "projectId");
        cat.createIndex("byItem", "item");
      }
    };

    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}


async function dbPut(item){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE, "readwrite");
    tx.objectStore(DB_STORE).put(item);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}
async function dbGetAll(){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE, "readonly");
    const req = tx.objectStore(DB_STORE).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
async function dbDelete(id){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE, "readwrite");
    tx.objectStore(DB_STORE).delete(id);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

async function dbDeleteMany(ids){
  if (!ids || !ids.length) return true;
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE, "readwrite");
    const store = tx.objectStore(DB_STORE);
    for (const id of ids) store.delete(id);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

async function deleteProjectData(projectId){
  const { projects } = ensureProjects();
  const activeId = getActiveProjectId() || ensureProjects().activeId;
  const firstId = projects[0]?.id || activeId;

  // borrar fotos del proyecto
  const all = await dbGetAll();
  const ids = [];
  for (const it of all){
    const pid = it.projectId ? it.projectId : firstId;
    if (pid === projectId) ids.push(it.id);
  }
  if (ids.length){
    $("backupStatus").textContent = `Eliminando fotos‚Ä¶ (${ids.length})`;
    await dbDeleteMany(ids);
  }

  // borrar cat√°logo del proyecto
  try{
    await catClearProject(projectId);
  }catch{}
  return true;
}

async function dbClear(){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE, "readwrite");
    tx.objectStore(DB_STORE).clear();
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

/* ===========================
   Cat√°logo de √≠tems (por proyecto)
=========================== */
let catalog = [];          // rows: {key, projectId, item, descripcion, createdAt}
let catalogMap = {};       // { itemCode: descripcion } para el proyecto activo

async function catGetByProject(projectId){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE_CATALOG, "readonly");
    const idx = tx.objectStore(DB_STORE_CATALOG).index("byProject");
    const req = idx.getAll(projectId);
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

async function catPutMany(rows){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE_CATALOG, "readwrite");
    const store = tx.objectStore(DB_STORE_CATALOG);
    for (const r of rows) store.put(r);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

async function catClearProject(projectId){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE_CATALOG, "readwrite");
    const store = tx.objectStore(DB_STORE_CATALOG);
    const idx = store.index("byProject");
    const req = idx.getAllKeys(projectId);
    req.onsuccess = () => {
      const keys = req.result || [];
      keys.forEach(k => store.delete(k));
    };
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

function rebuildCatalogMap(){
  catalogMap = {};
  for (const r of catalog){
    if (r?.item) catalogMap[String(r.item).trim()] = (r.descripcion || "").trim();
  }
}

async function loadCatalogForActiveProject(){
  const activeId = getActiveProjectId() || ensureProjects().activeId;
  catalog = await catGetByProject(activeId);
  rebuildCatalogMap();
  refreshCatalogDatalist();
  refreshCatalogStatus();
  updateExportItemHint();
}

function refreshCatalogDatalist(){
  const dl = $("datalistItems");
  if (!dl) return;
  dl.innerHTML = "";
  const rows = (catalog || []).slice().sort((a,b) => String(a.item).localeCompare(String(b.item)));
  for (const r of rows){
    const opt = document.createElement("option");
    opt.value = String(r.item || "").trim();
    opt.textContent = r.descripcion ? `${r.item} ‚Äî ${r.descripcion}` : String(r.item || "");
    dl.appendChild(opt);
  }
}

function refreshCatalogStatus(){
  const lab = $("itemsLabel");
  const st  = $("itemsStatus");
  const p = getActiveProject();
  const pname = p ? p.name : "‚Äî";
  if (lab) lab.textContent = `Listado por proyecto: ${pname}`;
  if (st) st.textContent = (catalog && catalog.length) ? `√çtems cargados: ${catalog.length}` : "Sin √≠tems cargados (a√∫n).";

}

function getExportItemCode(){
  return ($("exportItem")?.value || "").trim();
}

function updateExportItemHint(){
  const hintEl = $("exportItemHint");
  if (!hintEl) return;
  const code = getExportItemCode();
  hintEl.textContent = code ? (catalogMap[code] || "‚Äî") : "‚Äî";
}

function getGalleryItemCode(){
  return ($("galleryItem")?.value || "").trim();
}

function updateGalleryItemHint(){
  const hintEl = $("galleryItemHint");
  if (!hintEl) return;
  const code = getGalleryItemCode();
  hintEl.textContent = code ? (catalogMap[code] || "‚Äî") : "‚Äî";
}

function normalizeHeader(s){
  return String(s || "")
    .trim()
    .toLowerCase()
    .normalize("NFD")
    .replace(/[ÃÄ-ÕØ]/g,"")
    .replace(/\s+/g,"_");
}

async function importItemsFile(file){
  if (!file) return { added:0, skipped:0, total:0 };

  if (!window.XLSX){
    alert("No puedo leer Excel porque la librer√≠a XLSX no carg√≥. Abre con internet o prueba Chrome.");
    return { added:0, skipped:0, total:0 };
  }

  const ext = (file.name || "").toLowerCase();
  let wb;

  if (ext.endsWith(".csv")){
    const text = await file.text();
    wb = XLSX.read(text, { type:"string" });
  } else {
    const buf = await file.arrayBuffer();
    wb = XLSX.read(buf, { type:"array" });
  }

  const sheetName = wb.SheetNames.includes("ITEMS") ? "ITEMS" : wb.SheetNames[0];
  const ws = wb.Sheets[sheetName];
  const rows = XLSX.utils.sheet_to_json(ws, { header:1, raw:false, defval:"" });

  if (!rows.length) return { added:0, skipped:0, total:0 };

  const header = rows[0].map(normalizeHeader);
  const idxItem = header.findIndex(h => h === "item" || h === "codigo" || h === "codigo_item");
  const idxDesc = header.findIndex(h => h === "descripcion" || h === "descripci√≥n" || h === "descripcion_item");

  if (idxItem === -1 || idxDesc === -1){
    alert("Ese archivo no tiene el formato correcto. Debe tener columnas: ITEM y DESCRIPCION.");
    return { added:0, skipped:0, total:0 };
  }

  const p = getActiveProject();
  const projectId = p ? p.id : (getActiveProjectId() || "");
  if (!projectId){
    alert("No pude determinar el proyecto activo.");
    return { added:0, skipped:0, total:0 };
  }

  const batch = [];
  let added = 0, skipped = 0;

  for (let i=1; i<rows.length; i++){
    if ((i % 80) === 0){ try{ $("itemsStatus").textContent = `Importando‚Ä¶ (${Math.floor((i/Math.max(1,(rows.length-1)))*100)}%)`; }catch{} }
    const r = rows[i] || [];
    const item = String(r[idxItem] || "").trim();
    const descripcion = String(r[idxDesc] || "").trim();

    if (!item) { skipped++; continue; }

    const key = `${projectId}::${item}`;
    batch.push({
      key,
      projectId,
      item,
      descripcion,
      createdAt: Date.now()
    });
    added++;
  }

  await catPutMany(batch);
  await loadCatalogForActiveProject();

  return { added, skipped, total: rows.length-1 };
}

function downloadTemplateItems(){
  // Descarga la plantilla oficial desde el repo (m√°s confiable en Android/PWA).
  // Si falla, genera una plantilla m√≠nima.
  const url = `Logi2_Plantilla_Items.xlsx?v=${Date.now()}`;

  const forceDownload = async (blob, filename) => {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 1000);
  };

  (async () => {
    try{
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("No pude descargar la plantilla desde el servidor.");
      const blob = await res.blob();
      await forceDownload(blob, "Logi2_Plantilla_Items.xlsx");
      return;
    }catch(e){
      console.warn("Fallback plantilla (generada):", e);
      try{
        if (!window.XLSX) throw new Error("XLSX no carg√≥.");
        const wb = XLSX.utils.book_new();
        const data = [["ITEM","DESCRIPCION"],["",""]];
        const ws = XLSX.utils.aoa_to_sheet(data);
        ws["!cols"] = [{ wch: 18 }, { wch: 60 }];
        XLSX.utils.book_append_sheet(wb, ws, "ITEMS");
        const out = XLSX.write(wb, { bookType:"xlsx", type:"array" });
        const blob = new Blob([out], { type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
        await forceDownload(blob, "Logi2_Plantilla_Items.xlsx");
      }catch(err2){
        alert("No pude descargar/generar la plantilla.\n\nDetalle: " + (err2?.message || err2));
      }
    }
  })();
}


/* ===========================
   Utilidades
=========================== */
const fechaInput = $("fecha");
const proyectoInput = $("proyecto");
proyectoInput.addEventListener("input", () => setProjectDefault(proyectoInput.value));
const camInput = $("camInput");
const galInput = $("galInput");

const lista = $("lista");
const statusEl = $("status");
const rangeInfo = $("rangeInfo");
const zipInfo = $("zipInfo");

/* ===========================
   üß© Multi-proyecto (Logi2)
   - Separa fotos por "projectId" (en la misma DB)
   - NO toca /Logi/ porque usa DB_NAME distinto + keys logi2_*
=========================== */
const PROJECTS_KEY = "logi2_projects";
const ACTIVE_PROJECT_KEY = "logi2_active_project";

function genPid(){
  return "p_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,7);
}
function loadProjects(){
  try{ return JSON.parse(localStorage.getItem(PROJECTS_KEY) || "[]") || []; }catch{ return []; }
}
function saveProjects(arr){ localStorage.setItem(PROJECTS_KEY, JSON.stringify(arr)); }
function getActiveProjectId(){
  return localStorage.getItem(ACTIVE_PROJECT_KEY) || "";
}
function setActiveProjectId(id){
  localStorage.setItem(ACTIVE_PROJECT_KEY, id);
}
function ensureProjects(){
  let projects = loadProjects();
  if (!projects.length){
    const id = genPid();
    projects = [{ id, name: "Proyecto 1", createdAt: Date.now() }];
    saveProjects(projects);
    setActiveProjectId(id);
  }
  let activeId = getActiveProjectId();
  if (!activeId || !projects.some(p => p.id === activeId)){
    activeId = projects[0].id;
    setActiveProjectId(activeId);
  }
  return { projects, activeId };
}
function getActiveProject(){
  const { projects, activeId } = ensureProjects();
  return projects.find(p => p.id === activeId) || projects[0] || null;
}
function setProyectoInputFromActive(){
  // Mantener compatibilidad con UI vieja (campo "proyecto")
  const p = getActiveProject();
  if (proyectoInput && p){
    proyectoInput.value = p.name;
    proyectoInput.readOnly = true;   // el nombre se cambia con Renombrar
  }
}
function refreshProjectUI(){
  const sel = $("projectSelect");
  if (!sel) return;
  const { projects, activeId } = ensureProjects();
  sel.innerHTML = "";
  for (const p of projects){
    const opt = document.createElement("option");
    opt.value = p.id;
    opt.textContent = p.name;
    sel.appendChild(opt);
  }
  sel.value = activeId;
  setProyectoInputFromActive();
  const delSel = $("deleteProjectSelect");
  if (delSel){
    delSel.innerHTML = "";
    for (const p of projects){
      const opt2 = document.createElement("option");
      opt2.value = p.id;
      opt2.textContent = p.name;
      delSel.appendChild(opt2);
    }
    delSel.value = activeId;
  }

}

let projModalMode = null; // "new" | "rename"
function openProjModal(mode){
  projModalMode = mode;
  const p = getActiveProject();
  const modal = $("projModal");
  const title = $("projModalTitle");
  const meta = $("projModalMeta");
  const input = $("projNameInput");
  if (!modal || !input) return;

  if (mode === "new"){
    title.textContent = "Nuevo proyecto";
    meta.textContent = "Crea un proyecto para separar las fotos.";
    input.value = "";
  } else {
    title.textContent = "Renombrar proyecto";
    meta.textContent = "Este cambio solo afecta el nombre (las fotos quedan en el mismo proyecto).";
    input.value = p ? p.name : "";
  }

  modal.classList.add("open");
  modal.setAttribute("aria-hidden","false");

  // Focus suave para abrir teclado
  setTimeout(() => { input.focus(); input.setSelectionRange(input.value.length, input.value.length); }, 60);
}
function closeProjModal(){
  const modal = $("projModal");
  if (!modal) return;
  modal.classList.remove("open");
  modal.setAttribute("aria-hidden","true");
}

function onProjectChanged(){
  refreshProjectUI();

  // Limpia de inmediato para que NO se quede mostrando el proyecto anterior
  cache = [];
  render();
  updateStorageUI();

  (async () => {
    try{
      await loadCacheForActiveProject();
      await loadCatalogForActiveProject();
    }catch(e){
      console.error(e);
      alert("No pude actualizar la galer√≠a del proyecto. Si persiste, usa 'Reiniciar cach√©' en configuraci√≥n.");
    }finally{
      render();
      updateStorageUI();
    }
  })();
}

async function loadCacheForActiveProject(){
  const activeId = getActiveProjectId() || ensureProjects().activeId;
  const all = await dbGetAll();
  const { projects } = ensureProjects();
  const firstId = projects[0]?.id || activeId;

  // Sin migraci√≥n pesada: los legacy (sin projectId) se consideran del primer proyecto.
  cache = all.filter(it => (it.projectId ? it.projectId === activeId : activeId === firstId));
  setProyectoInputFromActive();
}

function attachProjectHandlers(){
  const sel = $("projectSelect");
  const btnNew = $("btnProjectNew");
  const btnRen = $("btnProjectRename");
  const btnClose = $("btnProjModalClose");
  const btnCancel = $("btnProjCancel");
  const btnSave = $("btnProjSave");
  const modal = $("projModal");

  if (sel){
    sel.addEventListener("change", () => {
      setActiveProjectId(sel.value);
      onProjectChanged();
    });
  }
  if (btnNew) btnNew.onclick = () => openProjModal("new");
  if (btnRen) btnRen.onclick = () => openProjModal("rename");
  if (btnClose) btnClose.onclick = closeProjModal;
  if (btnCancel) btnCancel.onclick = closeProjModal;

  if (modal){
    modal.addEventListener("click", (e) => {
      if (e.target === modal) closeProjModal();
    });
  }

  if (btnSave){
    btnSave.onclick = async () => {
      const input = $("projNameInput");
      if (!input) return;
      const name = (input.value || "").trim();
      if (!name){
        alert("Ponle un nombre al proyecto.");
        input.focus();
        return;
      }

      const { projects, activeId } = ensureProjects();

      if (projModalMode === "new"){
        const id = genPid();
        projects.push({ id, name, createdAt: Date.now() });
        saveProjects(projects);
        setActiveProjectId(id);
        refreshProjectUI();
        await loadCacheForActiveProject();
        render();
        updateStorageUI();
        closeProjModal();
        return;
      }

      // rename
      const p = projects.find(x => x.id === activeId);
      if (p){
        p.name = name;
        saveProjects(projects);

        // opcional: sincronizar campo "proyecto" en items del proyecto (para DOCX/nombres)
        // lo hacemos ligero: actualiza solo los del cache actual
        for (const it of cache){
          it.proyecto = name;
          await dbPut(it);
        }
      }
      refreshProjectUI();
      render();
      updateStorageUI();
      closeProjModal();
    };
  }
}


function hoyISO(){ return new Date().toISOString().slice(0,10); }
function ymdToNum(ymd){ return Number((ymd || "0000-00-00").replaceAll("-","")); }
function pad2(n){ return String(n).padStart(2,"0"); }

function sanitizeName(s){
  return (s || "")
    .trim()
    .replace(/[\/:*?"<>|]/g,"")
    .replace(/\s+/g,"_")
    .slice(0,60) || "Proyecto";
}


function escAttr(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll('"',"&quot;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");
}


function fmtBytes(bytes){
  if (bytes < 1024) return bytes + " B";
  const kb = bytes/1024;
  if (kb < 1024) return kb.toFixed(1) + " KB";
  const mb = kb/1024;
  return mb.toFixed(1) + " MB";
}

function filenameForItem(it, idxWithinDay, useTime){
  if (!useTime){
    return String(idxWithinDay).padStart(3,"0") + ".jpg";
  }
  const d = new Date(it.createdAt || Date.now());
  const hh = pad2(d.getHours());
  const mm = pad2(d.getMinutes());
  const ss = pad2(d.getSeconds());
  const suf = pad2(idxWithinDay);
  return `${hh}${mm}${ss}_${suf}.jpg`;
}

function formatDateLongES(iso){
  try{
    const [y,m,d] = iso.split("-").map(Number);
    const dt = new Date(y, m-1, d);
    return new Intl.DateTimeFormat("es-CO", { day:"numeric", month:"long", year:"numeric" }).format(dt);
  }catch{
    return iso;
  }
}

function formatStampDateTime(it){
  const baseDate = it.fecha || "";
  const dt = new Date(it.createdAt || Date.now());
  const hh = pad2(dt.getHours());
  const mm = pad2(dt.getMinutes());
  return baseDate ? `${baseDate} ${hh}:${mm}` : `${hh}:${mm}`;
}

/* ===========================
   üßæ Plantillas de salida (por dispositivo)
=========================== */
const TEMPLATES = {
  classic:  { name: "Cl√°sica (actual)", help: "Como siempre: DOCX usa 'FOTO N. descripci√≥n'. TXT solo descripci√≥n. (Sin texto sobre foto salvo que actives fecha/hora)." },
  minimal:  { name: "Minimal", help: "Descripci√≥n + fecha/hora (en DOCX/TXT).", },
  proyecto: { name: "Proyecto + descripci√≥n", help: "Incluye Proyecto (si existe) + descripci√≥n + fecha.", },
  fecha:    { name: "Solo fecha/hora", help: "Para fotos sin descripci√≥n: solo fecha y hora.", },
  clean:    { name: "Sin texto", help: "No agrega texto (DOCX deja 'FOTO N').", },
};

function getTemplateId(){
  return localStorage.getItem(TEMPLATE_KEY) || "classic";
}
function setTemplateId(id){
  localStorage.setItem(TEMPLATE_KEY, id);
  syncTemplateUI();
}

function getProjectDefault(){
  return (localStorage.getItem(PROJECT_KEY) || "").trim();
}
function setProjectDefault(v){
  localStorage.setItem(PROJECT_KEY, (v || "").trim());
}

function getTemplateMeta(it){
  const proj = (it.proyecto || "").trim() || (proyectoInput?.value || "").trim() || getProjectDefault();
  const desc = (it.descripcion || "").trim();
  const fecha = (it.fecha || "").trim();
  const longDate = fecha ? formatDateLongES(fecha) : "";
  const dt = new Date(it.createdAt || Date.now());
  const hh = pad2(dt.getHours());
  const mm = pad2(dt.getMinutes());
  const time = `${hh}:${mm}`;
  const stamp = fecha ? `${fecha} ${time}` : time;
  const itemCode = String(it.itemCode || "").trim();
  const itemDesc = String(it.itemDesc || (itemCode && catalogMap[itemCode]) || "").trim();
  return { proj, desc, fecha, longDate, time, stamp, itemCode, itemDesc };
}

function buildTemplateLines(meta, templateId){
  const id = templateId || "classic";
  if (id === "clean") return [];
  if (id === "fecha") return [meta.longDate || meta.fecha || "", meta.time].filter(Boolean);

  if (id === "minimal"){
    return [meta.desc || "‚Äî", meta.stamp].filter(Boolean);
  }

  if (id === "proyecto"){
    const lines = [];
    if (meta.proj) lines.push(meta.proj);
    if (meta.desc) lines.push(meta.desc);
    if (meta.longDate) lines.push(meta.longDate);
    return lines.length ? lines : ["‚Äî"];
  }

  // classic
  const lines = [];
  if (meta.desc) lines.push(meta.desc);
  else lines.push("‚Äî");
  return lines;
}

function buildDocxCaption(n, meta, templateId){
  // Formato solicitado (DOCX):
  // "Foto No. x, √≠tem: c√≥digo - descripci√≥n de √≠tem. Descripci√≥n de foto."
  const code = String(meta.itemCode || "").trim();
  const descItem = String(meta.itemDesc || "").trim();

  let itemLabel = "";
  if (code && descItem) itemLabel = `${code} - ${descItem}`;
  else if (code) itemLabel = code;
  else if (descItem) itemLabel = descItem;
  else itemLabel = "SIN ASIGNAR";

  const photoDesc = String(meta.desc || "‚Äî").trim() || "‚Äî";

  return `Foto No. ${n}, √≠tem: ${itemLabel}. ${photoDesc}`;
}


function syncTemplateUI(){
  const sel = $("templateSelect");
  const help = $("templateHelp");
  if (!sel || !help) return;
  const id = getTemplateId();
  sel.value = id;
  help.textContent = (TEMPLATES[id]?.help || "");
}




/* ===========================
   üìÑ Plantilla de p√°gina (4/6/8)
=========================== */
const LAYOUT_KEY = "logi_page_layout";
const PAGE_LAYOUTS = {
  p4: { rows: 2, cols: 2, label: "4" },
  p6: { rows: 3, cols: 2, label: "6" },
  p8: { rows: 4, cols: 2, label: "8" },
};

function getLayoutKey(){
  return localStorage.getItem(LAYOUT_KEY) || "p6";
}
function setLayoutKey(k){
  if (!PAGE_LAYOUTS[k]) k = "p6";
  localStorage.setItem(LAYOUT_KEY, k);
  syncLayoutUI();
}
function layoutFromKey(k){
  return PAGE_LAYOUTS[k] || PAGE_LAYOUTS.p6;
}
function docxDimsForLayout(k){
  const rows = layoutFromKey(k).rows;
  const imgWcm = 7.6;      // 2 columnas (estable)
  const imgHcmBase = 4.6;  // base para 8 fotos (4 filas)
  const imgHcm = +(imgHcmBase * (4 / rows)).toFixed(2);
  const pairsPerPage = rows; // 1 fila = 1 par (2 fotos)
  return { imgWcm, imgHcm, pairsPerPage };
}
function syncLayoutUI(){
  const pick = $("layoutPick");
  if (!pick) return;
  const k = getLayoutKey();
  pick.querySelectorAll(".layoutBtn").forEach(btn => {
    const on = (btn.getAttribute("data-layout") === k);
    btn.classList.toggle("active", on);
  });
}
function initLayoutUI(){
  const pick = $("layoutPick");
  if (!pick) return;
  pick.addEventListener("click", (e) => {
    const btn = e.target.closest(".layoutBtn");
    if (!btn) return;
    setLayoutKey(btn.getAttribute("data-layout"));
  });
  syncLayoutUI();
}
/* ===========================
   URLs temporales
=========================== */
let activeUrls = [];
function trackUrl(u){ activeUrls.push(u); return u; }
function revokeActiveUrls(){
  for (const u of activeUrls) {
    try { URL.revokeObjectURL(u); } catch {}
  }
  activeUrls = [];
}

/* ===========================
   Preferencias (DOCX fit)
=========================== */
function loadDocxFit(){
  const v = localStorage.getItem("logi_docx_fit") || "stretch";
  $("docxFit").value = v;
}
$("docxFit").onchange = () => localStorage.setItem("logi_docx_fit", $("docxFit").value);

$("templateSelect")?.addEventListener("change", () => setTemplateId($("templateSelect").value));

/* ===========================
   LOGO
=========================== */
let logoDataUrl = null;
let logoBitmap = null;

async function dataUrlToBitmap(dataUrl){
  try{
    const res = await fetch(dataUrl);
    const blob = await res.blob();
    if (window.createImageBitmap) return await createImageBitmap(blob);
  }catch{}
  return await new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = dataUrl;
  });
}

function syncLogoButtons(){
  const has = !!logoDataUrl;
  const q = document.getElementById("btnQuitarLogo");
  if (q) q.style.display = has ? "inline-flex" : "none";
}

async function loadLogoFromStorage(){
  // Nota: el logo NO se incrusta en la foto al capturar. Solo se aplica al exportar/compartir.
  localStorage.setItem("logi_logo_enabled","0");
  logoDataUrl = localStorage.getItem("logi_logo_dataurl");
if (logoDataUrl){
    $("logoPreview").src = logoDataUrl;
    $("logoPreview").style.display = "inline-block";
    try { logoBitmap = await dataUrlToBitmap(logoDataUrl); } catch { logoBitmap = null; }
  } else {
    $("logoPreview").style.display = "none";
    logoBitmap = null;
  }
  syncLogoButtons();
}

function loadLogoCorner(){
  const v = localStorage.getItem("logi_logo_corner") || "br";
  const el = document.getElementById("logoCorner");
  if (el) el.value = v;
}
{
  const el = document.getElementById("logoCorner");
  if (el) el.onchange = () => localStorage.setItem("logi_logo_corner", el.value);
}
{ const b = document.getElementById("btnCargarLogo"); if (b) b.onclick = () => document.getElementById("logoInput")?.click(); }
{ const inp = document.getElementById("logoInput"); if (inp) inp.onchange = async () => {
  const file = $("logoInput").files?.[0];
  if (!file) return;

  const dataUrl = await new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = reject;
    fr.readAsDataURL(file);
  });

  localStorage.setItem("logi_logo_dataurl", dataUrl);
  logoDataUrl = dataUrl;

  $("logoPreview").src = dataUrl;
  $("logoPreview").style.display = "inline-block";

  try {
    logoBitmap = await dataUrlToBitmap(dataUrl);
    syncLogoButtons();
    alert("Logo cargado ‚úÖ");
  } catch {
    alert("No pude cargar el logo. Prueba con un PNG.");
  } finally {
    $("logoInput").value = "";
  }
}; } 

{ const bq = document.getElementById("btnQuitarLogo"); if (bq) bq.onclick = async () => {
  if (!confirm("¬øQuitar el logo cargado?")) return;
  localStorage.removeItem("logi_logo_dataurl");
  logoDataUrl = null;
  logoBitmap = null;
  $("logoPreview").src = "";
  $("logoPreview").style.display = "none";
  syncLogoButtons();
  alert("Logo quitado ‚úÖ");
}; } 

/* ===========================
   Helpers esquina
=========================== */
function oppositeCorner(c){
  if (c === "br") return "tl";
  if (c === "tl") return "br";
  if (c === "bl") return "tr";
  if (c === "tr") return "bl";
  return "bl";
}

/* ===========================
   Compresi√≥n (captura)
=========================== */
function drawLogoAtCorner(ctx, W, H, corner, alpha=0.85){
  if (!logoBitmap) return false;

  const margin = Math.round(Math.min(W, H) * 0.02);
  const targetW = Math.round(W * 0.18);

  const lw = logoBitmap.width || logoBitmap.naturalWidth;
  const lh = logoBitmap.height || logoBitmap.naturalHeight;
  if (!lw || !lh) return false;

  const s = targetW / lw;
  const targetH = Math.round(lh * s);

  let x = W - targetW - margin;
  let y = H - targetH - margin;
  if (corner === "bl") { x = margin; y = H - targetH - margin; }
  if (corner === "tr") { x = W - targetW - margin; y = margin; }
  if (corner === "tl") { x = margin; y = margin; }

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.drawImage(logoBitmap, x, y, targetW, targetH);
  ctx.restore();

  return true;
}

function drawStampAtCorner(ctx, W, H, text, corner){
  const pad = Math.round(Math.min(W, H) * 0.02);
  const fontSize = Math.max(18, Math.round(Math.min(W, H) * 0.035));

  ctx.save();
  ctx.font = `700 ${fontSize}px Calibri, Arial, sans-serif`;
  ctx.textBaseline = "bottom";

  const metrics = ctx.measureText(text);
  const boxW = Math.round(metrics.width + pad * 1.4);
  const boxH = Math.round(fontSize + pad * 1.2);

  let x = pad;
  let y = H - pad;
  if (corner === "br") { x = W - pad; y = H - pad; }
  if (corner === "tr") { x = W - pad; y = pad + boxH; }
  if (corner === "tl") { x = pad; y = pad + boxH; }

  let boxX, boxY;
  if (corner === "bl"){
    boxX = x - Math.round(pad*0.6);
    boxY = y - boxH;
  } else if (corner === "br"){
    boxX = x - boxW + Math.round(pad*0.6);
    boxY = y - boxH;
  } else if (corner === "tr"){
    boxX = x - boxW + Math.round(pad*0.6);
    boxY = y - boxH;
  } else {
    boxX = x - Math.round(pad*0.6);
    boxY = y - boxH;
  }

  ctx.fillStyle = "rgba(2, 6, 23, 0.55)";
  ctx.fillRect(boxX, boxY, boxW, boxH);

  ctx.fillStyle = "rgba(255,255,255,0.95)";
  ctx.textAlign = (corner === "br" || corner === "tr") ? "right" : "left";
  ctx.fillText(text, x, y - Math.round(pad*0.3));

  ctx.restore();
}

async function compressImage(file, maxSide=1600, quality=0.82){
  if (!file.type.startsWith("image/")) return { blob: file, hasLogo: false };

  const img = new Image();
  const url = URL.createObjectURL(file);

  await new Promise((res, rej) => {
    img.onload = () => res();
    img.onerror = rej;
    img.src = url;
  });

  const w = img.naturalWidth, h = img.naturalHeight;
  const scale = Math.min(1, maxSide / Math.max(w,h));
  const nw = Math.round(w * scale);
  const nh = Math.round(h * scale);

  const canvas = document.createElement("canvas");
  canvas.width = nw; canvas.height = nh;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, nw, nh);

  URL.revokeObjectURL(url);

  const enabled = false; // nunca incrustamos logo en captura
  const corner = localStorage.getItem("logi_logo_corner") || "br";
  const hadLogo = false;

  const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/jpeg", quality));
  return { blob: blob || file, hasLogo: !!hadLogo };
}

/* ===========================
   Overlays (logo + fecha/hora)
=========================== */
function roundRectPath(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

function wrapLine(ctx, text, maxW){
  const words = String(text || "").split(/\s+/).filter(Boolean);
  if (!words.length) return [""];
  const out = [];
  let cur = words[0];
  for (let i=1;i<words.length;i++){
    const test = cur + " " + words[i];
    if (ctx.measureText(test).width <= maxW) cur = test;
    else { out.push(cur); cur = words[i]; }
  }
  out.push(cur);
  return out;
}

function chooseTextCornerForLogo(logoCorner){
  // Preferimos la esquina inferior opuesta horizontalmente al logo
  if (logoCorner === "bl" || logoCorner === "tl") return "br";
  return "bl";
}

function drawTemplateBlock(ctx, W, H, lines, logoCorner){
  const clean = (lines || []).map(s => String(s || "").trim()).filter(Boolean);
  if (!clean.length) return;

  const corner = chooseTextCornerForLogo(logoCorner || "br");
  const pad = Math.round(Math.min(W, H) * 0.02);
  const maxW = Math.round(W * 0.86);

  // Tipograf√≠a
  const base = Math.max(18, Math.round(Math.min(W, H) * 0.035));
  const titleSize = base + 2;
  const bodySize = base;

  // Pre-medici√≥n con wrapping
  const temp = [];
  ctx.save();
  ctx.textBaseline = "top";

  // l√≠nea 1 (m√°s fuerte)
  ctx.font = `900 ${titleSize}px Calibri, Arial, sans-serif`;
  const first = wrapLine(ctx, clean[0], maxW);
  temp.push(...first.map(t => ({ t, size: titleSize, weight: 900 })));

  // resto
  ctx.font = `700 ${bodySize}px Calibri, Arial, sans-serif`;
  for (let i=1;i<clean.length;i++){
    const wrapped = wrapLine(ctx, clean[i], maxW);
    temp.push(...wrapped.map(t => ({ t, size: bodySize, weight: 700 })));
  }

  const lineGap = Math.round(bodySize * 0.35);
  let textW = 0;
  temp.forEach(L => {
    ctx.font = `${L.weight} ${L.size}px Calibri, Arial, sans-serif`;
    textW = Math.max(textW, ctx.measureText(L.t).width);
  });

  const textH = temp.reduce((sum, L) => sum + L.size + lineGap, 0) - lineGap;
  const boxW = Math.round(textW + pad * 1.6);
  const boxH = Math.round(textH + pad * 1.4);

  let x = pad, y = H - pad - boxH;
  if (corner === "br") x = W - pad - boxW;

  // fondo
  ctx.fillStyle = "rgba(2, 6, 23, 0.58)";
  roundRectPath(ctx, x, y, boxW, boxH, Math.round(pad*0.8));
  ctx.fill();

  // texto
  let cy = y + Math.round(pad*0.7);
  for (const L of temp){
    ctx.font = `${L.weight} ${L.size}px Calibri, Arial, sans-serif`;
    ctx.fillStyle = "rgba(255,255,255,0.96)";
    ctx.fillText(L.t, x + Math.round(pad*0.8), cy);
    cy += L.size + lineGap;
  }

  ctx.restore();
}

async function applyExportOverlaysToBlob(originalBlob, options){
  const { addLogo, addStamp, stampText, avoidDoubleLogo, addTemplate, templateLines, logoCornerHint } = options;

  const bmp = await createImageBitmap(originalBlob);
  const canvas = document.createElement("canvas");
  canvas.width = bmp.width;
  canvas.height = bmp.height;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(bmp, 0, 0);

  const logoCorner = localStorage.getItem("logi_logo_corner") || "br";

  const willHaveLogo =
    (addLogo && logoBitmap && !avoidDoubleLogo) ||
    (avoidDoubleLogo === true);

  if (addLogo && logoBitmap && !avoidDoubleLogo){
    drawLogoAtCorner(ctx, canvas.width, canvas.height, logoCorner, 0.85);
  }

  if (addStamp && stampText){
    let stampCorner = willHaveLogo ? oppositeCorner(logoCorner) : "tr";
    // si hay plantilla, preferimos arriba para evitar choque con el bloque inferior
    if (addTemplate) stampCorner = (logoCorner === "bl" || logoCorner === "tl") ? "tr" : "tl";
    if (stampCorner === "bl" || stampCorner === "br") stampCorner = "tr";
    drawStampAtCorner(ctx, canvas.width, canvas.height, stampText, stampCorner);
  }


  // Plantilla (bloque de texto) ‚Äî se dibuja al final para que quede legible
  if (addTemplate && Array.isArray(templateLines) && templateLines.length){
    const lc = logoCornerHint || logoCorner;
    drawTemplateBlock(ctx, canvas.width, canvas.height, templateLines, lc);
  }

  const out = await new Promise(res => canvas.toBlob(res, "image/jpeg", 0.9));
  return out || originalBlob;
}

/* ===========================
   Estado / Datos
=========================== */
let cache = [];
let viewMode = "captura";

function setStatus(){
  const count = cache.length;
  const doneCount = cache.filter(x => x.done).length;
  const totalBytes = cache.reduce((a,i)=>a+(i.blob?.size||0),0);

  let minDate = null, maxDate = null;
  for (const it of cache){
    if (!it.fecha) continue;
    if (!minDate || it.fecha < minDate) minDate = it.fecha;
    if (!maxDate || it.fecha > maxDate) maxDate = it.fecha;
  }
  rangeInfo.textContent = minDate ? `Rango: ${minDate} ‚Üí ${maxDate}` : "Rango: ‚Äî";

  statusEl.innerHTML =
    `<span class="${count? 'ok':''}">${count} foto(s)</span>` +
    ` ¬∑ <span class="muted">${doneCount} listas</span>` +
    ` ¬∑ <span class="muted">${fmtBytes(totalBytes)}</span>`;
}

function groupByDate(items){
  const map = new Map();
  for (const it of items){
    const d = it.fecha || "Sin_fecha";
    if (!map.has(d)) map.set(d, []);
    map.get(d).push(it);
  }
  const dates = Array.from(map.keys()).sort((a,b)=> b.localeCompare(a));
  return dates.map(d => {
    const arr = map.get(d).slice().sort((x,y)=> (x.createdAt - y.createdAt));
    return [d, arr];
  });
}

/* ===========================
   Render: Captura
=========================== */
function renderCaptura(){
  lista.innerHTML = "";
  setStatus();

  const fecha = fechaInput.value || hoyISO();
  const items = cache
    .filter(x => x.fecha === fecha)
    .sort((a,b)=> (a.done === b.done ? (a.createdAt - b.createdAt) : (a.done - b.done)));

  if (!items.length){
    lista.innerHTML = `<div class="muted">No hay fotos guardadas para ${fecha}.</div>`;
    return;
  }

  items.forEach((item, idx) => {
    const div = document.createElement("div");
    div.className = "item" + (item.done ? " done" : "");

    const thumbUrl = trackUrl(URL.createObjectURL(item.blob));
    const shareDisabled = !item.done;

    div.innerHTML = `
      <div class="itemTop">
        <img class="thumb ${String(item.itemCode||"").trim() ? "" : "thumbMissing"}" src="${thumbUrl}" data-open="${item.id}" alt="foto">
        <div class="grow">
          <div class="mini">
            <span>#${idx+1} ¬∑ ${item.fecha}</span>
            ${item.proyecto ? `<span>¬∑ ${item.proyecto}</span>` : `<span>¬∑ ‚Äî</span>`}
            ${item.itemCode ? `<span>¬∑ ${item.itemCode}</span>` : ``}
            ${item.done ? `<span class="chip-done">LISTO</span>` : ``}
          </div>

          <label style="margin-top:6px">√çtem (opcional)</label>
          <input data-id="${item.id}" class="itSel" type="text" list="datalistItems" placeholder="C√≥digo o busca en el listado‚Ä¶" ${item.done ? "disabled" : ""} value="${escAttr(item.itemCode || "")}"/>
          <div class="muted" style="margin-top:4px" data-ithint="${item.id}">${item.itemCode ? (catalogMap[item.itemCode] ? catalogMap[item.itemCode] : "") : ""}</div>

          <label style="margin-top:6px;display:flex;align-items:center;justify-content:space-between;gap:10px">
  <span>Descripci√≥n</span>
  <button class="btn btn-secondary smallBtn dictate" data-id="${item.id}" title="Dictar (voz)" ${item.done ? "disabled" : ""}>üéôÔ∏è</button>
</label>
<textarea data-id="${item.id}" class="desc" ${item.done ? "disabled" : ""}>${item.descripcion || ""}</textarea>

          <div class="row" style="margin-top:8px;justify-content:space-between;">
            <div class="row">
              <button class="btn btn-secondary smallBtn toggleDone" data-id="${item.id}">
                ${item.done ? "‚úèÔ∏è Editar" : "‚úÖ Listo"}
              </button>

              <button class="btn btn-secondary smallBtn shareOne ${shareDisabled ? "btn-disabled" : ""}" data-id="${item.id}" ${shareDisabled ? "disabled" : ""}>
                üì§ WhatsApp
              </button>
            </div>

            <div class="right">
              <button class="btn btn-danger smallBtn del" data-id="${item.id}">üóëÔ∏è</button>
            </div>
          </div>
        </div>
      </div>
    `;
    lista.appendChild(div);
  });

  wireEventsCaptura();
}


function wireEventsCaptura(){
  document.querySelectorAll("textarea.desc").forEach(t => {
    t.oninput = async () => {
      const id = Number(t.dataset.id);
      const obj = cache.find(x => x.id === id);
      if (!obj) return;
      obj.descripcion = t.value;
      await dbPut(obj);
    };
  });

  // üéôÔ∏è Dictado por voz: bot√≥n por foto (captura)
  document.querySelectorAll("button.dictate").forEach(b => {
    b.onclick = () => {
      const id = Number(b.dataset.id);
      const t = document.querySelector(`textarea.desc[data-id="${id}"]`);
      startDictation(t, b);
    };
  });
  document.querySelectorAll("input.itSel").forEach(inp => {
    inp.oninput = async () => {
      const id = Number(inp.dataset.id);
      const obj = cache.find(x => x.id === id);
      if (!obj || obj.done) return;
      const code = (inp.value || "").trim();
      obj.itemCode = code;
      obj.itemDesc = (code && catalogMap[code]) ? catalogMap[code] : "";
      await dbPut(obj);
      const h = document.querySelector(`[data-ithint="${id}"]`);
      if (h) h.textContent = obj.itemDesc || "";
    };
  });

  document.querySelectorAll("button.del").forEach(b => {
    b.onclick = async () => {
      const id = Number(b.dataset.id);
      if (!confirm("¬øEliminar esta foto?")) return;
      await dbDelete(id);
      cache = cache.filter(x => x.id !== id);
      render();
    };
  });

  document.querySelectorAll("button.toggleDone").forEach(b => {
    b.onclick = async () => {
      const id = Number(b.dataset.id);
      const obj = cache.find(x => x.id === id);
      if (!obj) return;
      obj.done = !obj.done;
      await dbPut(obj);
      render();
    };
  });

  document.querySelectorAll("button.shareOne").forEach(b => {
    b.onclick = async () => {
      const id = Number(b.dataset.id);
      const obj = cache.find(x => x.id === id);
      if (!obj) return;
      await shareOnlyImage(obj);
    };
  });

  document.querySelectorAll("img.thumb").forEach(img => {
    img.onclick = () => openModal(Number(img.dataset.open));
  });
}

/* ===========================
   Render: Galer√≠a
=========================== */
function renderGaleria(){
  setStatus();
  const wrap = $("galleryWrap");
  wrap.innerHTML = "";
  const gcode = getGalleryItemCode();
  let source = cache;
  if (gcode) source = cache.filter(x => String(x.itemCode || "").trim() === gcode);

  const groups = groupByDate(source);

  const ri = $("rangeInfo");
  if (ri && gcode){
    const base = ri.textContent || "Rango: ‚Äî";
    ri.textContent = base.includes("√çtem:") ? base : (base + ` ¬∑ √çtem: ${gcode}`);
  }
if (!groups.length){
    wrap.innerHTML = `<div style="padding:12px" class="muted">A√∫n no hay fotos guardadas.</div>`;
    return;
  }

  for (const [date, items] of groups){
    const day = document.createElement("div");
    const doneCount = items.filter(x => x.done).length;
    const bytes = items.reduce((a,i)=>a+(i.blob?.size||0),0);
    const missItemCount = items.filter(x => !(String(x.itemCode || "").trim())).length;

    day.innerHTML = `
      <div class="dayHeader">
        <div class="dayTitle"><span class="dayChip">${formatDateLongES(date)}</span></div>
        <div class="dayMeta">¬∑ ${items.length} foto(s) ¬∑ ${doneCount} listas${missItemCount ? ` ¬∑ ${missItemCount} sin √≠tem` : ``} ¬∑ ${fmtBytes(bytes)}</div>
      </div>
      <div class="gridThumbs" data-day="${date}"></div>
    `;
    wrap.appendChild(day);

    const grid = day.querySelector(".gridThumbs");
    items.forEach(it => {
      const box = document.createElement("div");
      box.className = "gThumbBox";
      const url = trackUrl(URL.createObjectURL(it.blob));
      const hasItem = !!String(it.itemCode || "").trim();
      const codeShort = hasItem ? String(it.itemCode || "").trim().slice(0, 14) : "";
      box.innerHTML = `
        <img class="gThumb ${hasItem ? "" : "gThumbMissing"}" src="${url}" data-open="${it.id}" alt="foto">
        <div class="badge ${it.done ? "badgeDone" : ""}">${it.done ? "LISTO" : "PEND"}</div>
        <div class="badge badgeItem ${hasItem ? "badgeItemOk" : "badgeItemMiss"}">${hasItem ? escAttr(codeShort) : "√çTEM?"}</div>
        <div class="badge badgeShare">üì§</div>
      `;
      grid.appendChild(box);
    });
  }

  wrap.querySelectorAll("img.gThumb").forEach(img => {
    img.onclick = () => openModal(Number(img.dataset.open));
  });
}

/* ===========================
   Modal
=========================== */
let modalId = null;

function openModal(id){
  const it = cache.find(x => x.id === id);
  if (!it) return;

  modalId = id;
  $("modal").classList.add("open");

  const url = trackUrl(URL.createObjectURL(it.blob));
  $("modalImg").src = url;

  $("modalTitle").textContent = it.proyecto ? it.proyecto : "Foto";
  $("modalMeta").textContent = `${it.fecha} ¬∑ ${it.done ? "LISTA" : "PENDIENTE"}`;

  $("modalItem").value = it.itemCode || "";
  $("modalItem").disabled = !!it.done;
  $("modalItemHint").textContent = (it.itemCode && catalogMap[it.itemCode]) ? catalogMap[it.itemCode] : "‚Äî";

  $("modalDesc").value = it.descripcion || "";
  $("modalDesc").disabled = !!it.done;

  $("btnModalDone").textContent = it.done ? "‚úèÔ∏è Editar" : "‚úÖ Listo";
  $("btnModalShare").disabled = !it.done;
  $("btnModalShare").classList.toggle("btn-disabled", !it.done);
}

function closeModal(){
  if (typeof dictation !== "undefined" && dictation.active) stopDictation();
  $("modal").classList.remove("open");
  $("modalImg").src = "";
  modalId = null;
}

$("btnModalClose").onclick = closeModal;
$("modal").addEventListener("click", (e) => {
  if (dictation.active) stopDictation();
  if (e.target.id === "modal") closeModal();
});


$("modalItem").oninput = async () => {
  if (modalId == null) return;
  const it = cache.find(x => x.id === modalId);
  if (!it || it.done) return;
  const code = ($("modalItem").value || "").trim();
  it.itemCode = code;
  it.itemDesc = (code && catalogMap[code]) ? catalogMap[code] : "";
  $("modalItemHint").textContent = it.itemDesc || "‚Äî";
  await dbPut(it);
  // refrescar hints en captura
  const h = document.querySelector(`[data-ithint="${it.id}"]`);
  if (h) h.textContent = it.itemDesc || "";
};

$("modalDesc").oninput = async () => {
  if (modalId == null) return;
  const it = cache.find(x => x.id === modalId);
  if (!it || it.done) return;
  it.descripcion = $("modalDesc").value;
  await dbPut(it);
};

$("btnModalDone").onclick = async () => {
  if (modalId == null) return;
  const it = cache.find(x => x.id === modalId);
  if (!it) return;
  it.done = !it.done;
  await dbPut(it);
  render();
  openModal(it.id);
};

$("btnModalDelete").onclick = async () => {
  if (modalId == null) return;
  const it = cache.find(x => x.id === modalId);
  if (!it) return;
  if (!confirm("¬øEliminar esta foto?")) return;
  await dbDelete(it.id);
  cache = cache.filter(x => x.id !== it.id);
  closeModal();
  render();
};


// üéôÔ∏è Dictado por voz en modal
$("btnModalDictate").onclick = () => {
  startDictation($("modalDesc"), $("btnModalDictate"));
};
$("btnModalShare").onclick = async () => {
  if (modalId == null) return;
  const it = cache.find(x => x.id === modalId);
  if (!it) return;
  await shareOnlyImage(it);
};

/* ===========================
   WhatsApp (solo imagen)
=========================== */
async function shareOnlyImage(it){
  const safeProject = sanitizeName(it.proyecto || "Foto");
  const name = `${it.fecha}_${safeProject}.jpg`;

  let blobToShare = it.blob;

  const wantLogo = !!$("waAddLogo")?.checked;
  const wantTemplate = !!$("waAddTemplate")?.checked;
  const wantStamp = !!$("waAddStamp")?.checked;

    if (wantLogo || wantStamp || (wantTemplate && (getTemplateId() !== "classic") && (getTemplateId() !== "clean"))){
    blobToShare = await applyExportOverlaysToBlob(it.blob, {
      addLogo: wantLogo && !!logoBitmap,
      addStamp: wantStamp,
      stampText: wantStamp ? formatStampDateTime(it) : "",
      avoidDoubleLogo: wantLogo && !!it.hasLogo,
      addTemplate: wantTemplate && (getTemplateId() !== "classic") && (getTemplateId() !== "clean"),
      templateLines: (wantTemplate && (getTemplateId() !== "classic") && (getTemplateId() !== "clean")) ? buildTemplateLines(getTemplateMeta(it), getTemplateId()) : [],
      logoCornerHint: localStorage.getItem("logi_logo_corner") || "br"
    });
  }

  const file = new File([blobToShare], name, { type: "image/jpeg" });

  if (navigator.share && (!navigator.canShare || navigator.canShare({ files: [file] }))){
    try { await navigator.share({ files: [file], title: "Foto" }); return; }
    catch { return; }
  }

  const url = URL.createObjectURL(blobToShare);
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  alert("Tu navegador no permite compartir archivos directo.\nSe descarg√≥ la foto para que la env√≠es por WhatsApp.");
}

/* ===========================
   Captura
=========================== */
$("btnTomarFoto").onclick = () => {
  camInput.value = "";
  camInput.click();
};

$("btnGaleria").onclick = () => {
  galInput.value = "";
  galInput.click();
};

async function ingestPhotos(fileList){
  const files = Array.from(fileList || []);
  if (!files.length) return;

  const fecha = fechaInput.value || hoyISO();
  const activeProject = getActiveProject();
  const proyecto = activeProject ? activeProject.name : (proyectoInput.value || "").trim();
  const projectId = activeProject ? activeProject.id : null;

  zipInfo.textContent = `Procesando ${files.length} foto(s)...`;
  for (const file of files){
    const { blob, hasLogo } = await compressImage(file);

    const item = {
      id: Date.now() + Math.floor(Math.random()*1000),
      fecha,
      proyecto,
      descripcion: "",
      done: false,
      blob,
      mime: "image/jpeg",
      createdAt: Date.now(),
      hasLogo: !!hasLogo,
      projectId: projectId
    };

    await dbPut(item);
    cache.push(item);
  }

  zipInfo.textContent = "";
  render();
  updateStorageUI();
}

camInput.onchange = async () => {
  await ingestPhotos(camInput.files);
  camInput.value = "";
};

galInput.onchange = async () => {
  await ingestPhotos(galInput.files);
  galInput.value = "";
};



/* ===========================
   DOCX helpers + DOCX builder
=========================== */
function cmToPx(cm){ return Math.round((cm / 2.54) * 96); }

function computeRangeForTitle(modo, desde, hasta){
  if (modo === "mes"){
    const ym = (desde || hoyISO()).slice(0,7);
    const [y, m] = ym.split("-").map(Number);
    const start = `${ym}-01`;
    const last = new Date(y, m, 0).getDate();
    const end = `${ym}-${String(last).padStart(2,"0")}`;
    return { start, end };
  }
  if (modo === "dia") return { start: desde, end: desde };
  return { start: desde, end: hasta };
}

async function normalizeToFixedFrameJpg(blob, frameW=1600, frameH=1000, quality=0.9, fit="stretch"){
  const bmp = await createImageBitmap(blob);
  const canvas = document.createElement("canvas");
  canvas.width = frameW;
  canvas.height = frameH;
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,frameW,frameH);

  const bw = bmp.width, bh = bmp.height;

  if (fit === "stretch"){
    ctx.drawImage(bmp, 0, 0, frameW, frameH);
  } else if (fit === "cover"){
    const scale = Math.max(frameW / bw, frameH / bh);
    const nw = Math.round(bw * scale);
    const nh = Math.round(bh * scale);
    const x = Math.round((frameW - nw) / 2);
    const y = Math.round((frameH - nh) / 2);
    ctx.drawImage(bmp, x, y, nw, nh);
  } else {
    const scale = Math.min(frameW / bw, frameH / bh);
    const nw = Math.round(bw * scale);
    const nh = Math.round(bh * scale);
    const x = Math.round((frameW - nw) / 2);
    const y = Math.round((frameH - nh) / 2);
    ctx.drawImage(bmp, x, y, nw, nh);
  }

  const out = await new Promise(res => canvas.toBlob(res, "image/jpeg", quality));
  return out || blob;
}

async function loadLogiLogoArrayBuffer(){
  // Cache-first + timeout para que NUNCA cuelgue el export (PWA/Android)
  // 1) intenta cache del SW (offline)
  try{
    if (window.caches && caches.match){
      const cached = await caches.match("./icon-192.png");
      if (cached) return await cached.arrayBuffer();
    }
  }catch{}

  // 2) fallback: fetch con timeout (no-store a veces cuelga)
  try{
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), 1500);
    const r = await fetch("./icon-192.png", { cache: "force-cache", signal: ctrl.signal });
    clearTimeout(t);
    if (r && r.ok) return await r.arrayBuffer();
  }catch{}

  return null;
}


// ===========================
// Ajuste autom√°tico de fuente (DOCX captions)
// Mantiene 8 fotos/p√°gina sin que el texto "reviente" la caja
// ===========================
const _CAPTION_MAX_LINES = 4;
const _CAPTION_FONT_PT_BASE = 9.5;
const _CAPTION_FONT_PT_MIN  = 6.5;

// Ancho √∫til aproximado del texto dentro de cada caption (cm)
// A4 (21cm) - m√°rgenes (1.27cm*2) = 18.46cm; /2 columnas = 9.23cm
// menos m√°rgenes internos del cell (~0.5cm) => ~8.7cm
const _CAPTION_TEXT_W_CM = 8.7;

let _measureCanvas = null;
function _getMeasureCtx(fontPx){
  if (!_measureCanvas) _measureCanvas = document.createElement("canvas");
  const ctx = _measureCanvas.getContext("2d");
  ctx.font = `${fontPx}px Calibri, Arial, sans-serif`;
  return ctx;
}
function _cmToPx96(cm){ return (cm / 2.54) * 96; }

function _wrapCountLines(text, fontPx, maxWidthPx){
  const clean = String(text || "").replace(/\s+/g, " ").trim();
  if (!clean) return 0;

  const ctx = _getMeasureCtx(fontPx);
  // para medir el prefijo en negrita
  if (!_measureCanvas) _measureCanvas = document.createElement("canvas");
  const ctxB = _measureCanvas.getContext("2d");
  ctxB.font = `bold ${fontPx}px Calibri, Arial, sans-serif`;

  const fits = (s, w) => ctx.measureText(s).width <= w;

  // Rompe un token sin espacios en trozos que quepan en 'wPx'
  const splitToken = (tok, wPx) => {
    const out = [];
    let chunk = "";
    for (const ch of tok){
      const t = chunk + ch;
      if (fits(t, wPx) || !chunk){
        chunk = t;
      } else {
        out.push(chunk);
        chunk = ch;
      }
    }
    if (chunk) out.push(chunk);
    return out;
  };

  // Consume tokens para armar UNA l√≠nea con l√≠mite 'wPx'. Devuelve { line, restTokens }
  const takeLine = (tokens, wPx) => {
    let line = "";
    let i = 0;
    while (i < tokens.length){
      let tok = tokens[i];

      // token gigante al inicio -> partirlo
      if (!line && !fits(tok, wPx)){
        const parts = splitToken(tok, wPx);
        line = parts[0] || "";
        const rest = parts.slice(1).concat(tokens.slice(i+1));
        return { line, restTokens: rest };
      }

      const test = line ? (line + " " + tok) : tok;
      if (fits(test, wPx)){
        line = test;
        i++;
      } else {
        break;
      }
    }
    return { line, restTokens: tokens.slice(i) };
  };

  // Wrap de tokens en m√∫ltiples l√≠neas con l√≠mite 'wPx'
  const wrapTokens = (tokens, wPx) => {
    const lines = [];
    let rest = tokens.slice();
    while (rest.length){
      const r = takeLine(rest, wPx);
      if (r.line) lines.push(r.line);
      rest = r.restTokens;
      // safety: evita loops raros
      if (!r.line && rest.length) { lines.push(rest.shift()); }
    }
    return lines;
  };

  // Detecta prefijo real (como en el DOCX / PDF)
  const m = clean.match(/^(Foto No\. \d+,|FOTO \d+\.)\s*/);
  if (m){
    const prefix = m[1];
    const rest = clean.slice(m[0].length).trimStart();

    const spaceW = ctx.measureText(" ").width;
    const prefixW = ctxB.measureText(prefix).width;
    const firstMax = Math.max(20, maxWidthPx - prefixW - spaceW);

    const restTokens = rest ? rest.split(" ") : [];
    const first = takeLine(restTokens, firstMax);
    const other = wrapTokens(first.restTokens, maxWidthPx);

    // 1 l√≠nea inicial siempre existe por el prefijo
    return 1 + other.length;
  }

  // Sin prefijo: wrap normal
  const tokens = clean.split(" ");
  return wrapTokens(tokens, maxWidthPx).length;
}

function _fitCaptionFontPt(text){
  const maxWidthPx = _cmToPx96(_CAPTION_TEXT_W_CM);

  // b√∫squeda binaria de fontPx (pt -> px)
  const ptToPx = (pt) => (pt * 96) / 72;

  let lo = _CAPTION_FONT_PT_MIN;
  let hi = _CAPTION_FONT_PT_BASE;
  let best = lo;

  for (let i = 0; i < 10; i++){
    const mid = (lo + hi) / 2;
    const lines = _wrapCountLines(text, ptToPx(mid), maxWidthPx);
    if (lines <= _CAPTION_MAX_LINES){
      best = mid;
      lo = mid;
    }else{
      hi = mid;
    }
  }
  // redondeo a .1pt para estabilidad visual
  return Math.max(_CAPTION_FONT_PT_MIN, Math.min(_CAPTION_FONT_PT_BASE, Math.round(best*10)/10));
}

function buildCaptionRunsSized(n, caption, sizeHp){
  const prefixNew = `Foto No. ${n},`;
  const prefixOld = `FOTO ${n}.`;
  let prefix = prefixNew;
  if (caption.startsWith(prefixNew)) prefix = prefixNew;
  else if (caption.startsWith(prefixOld)) prefix = prefixOld;
  else prefix = "";

  const rest = prefix ? caption.slice(prefix.length).trimStart() : caption;
  const { TextRun } = window.docx;

  if (!prefix){
    return [ new TextRun({ text: caption, size: sizeHp }) ];
  }

  return [
    new TextRun({ text: prefix, bold: true, size: sizeHp }),
    new TextRun({ text: rest ? (" " + rest) : "", size: sizeHp })
  ];
}

// Compat: si alg√∫n otro lugar llama buildCaptionRuns, queda igual (9.5pt aprox)
function buildCaptionRuns(n, meta, templateId){
  const caption = buildDocxCaption(n, meta, templateId);
  return buildCaptionRunsSized(n, caption, Math.round(_CAPTION_FONT_PT_BASE*2));
}

async function buildRegistroFotograficoDocxBuffer(
  selected, tituloProyecto, startISO, endISO, imgWcm, imgHcm,
  pairsPerPage = 4,
  exportOpts=null
){
  const {
    Document, Packer, Paragraph, TextRun,
    AlignmentType, Table, TableRow, TableCell, WidthType,
    ImageRun, PageBreak, BorderStyle, Header, VerticalAlign, HeightRule
  } = window.docx;

  const docDefaultStyles = {
    styles: {
      default: {
        document: {
          run: { font: "Calibri", size: 18 },
          paragraph: { spacing: { before: 0, after: 0 } }
        }
      }
    }
  };

  const BRAND_DARK = "0B1220";
  const BRAND_MID  = "111B2E";
  const BRAND_ACC  = "3B82F6";
  const GRID_COL   = "2F6FED"; // bordes un poquito m√°s sobrios
  const CAPTION_ROW_H = 1120; // twips (~2.1cm) -> 4 l√≠neas sin desbordar

  const noneBorders = {
    top:    { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
    bottom: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
    left:   { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
    right:  { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
  };

  const gridBorders = {
    top:    { style: BorderStyle.SINGLE, size: 2, color: GRID_COL },
    bottom: { style: BorderStyle.SINGLE, size: 2, color: GRID_COL },
    left:   { style: BorderStyle.SINGLE, size: 2, color: GRID_COL },
    right:  { style: BorderStyle.SINGLE, size: 2, color: GRID_COL },
    insideHorizontal: { style: BorderStyle.SINGLE, size: 2, color: GRID_COL },
    insideVertical:   { style: BorderStyle.SINGLE, size: 2, color: GRID_COL },
  };

  const IMG_W = cmToPx(imgWcm);
  const IMG_H = cmToPx(imgHcm);

  const ratio = IMG_W / IMG_H;
  let frameW = 1600;
  if ((selected?.length || 0) > 240) frameW = 1000;
  else if ((selected?.length || 0) > 120) frameW = 1200;
  const frameH = Math.round(frameW / ratio);
  const fitMode = localStorage.getItem("logi_docx_fit") || "stretch";

  const startLong = formatDateLongES(startISO);
  const endLong = formatDateLongES(endISO);
  const sameDay = (startISO === endISO);

  const titleLine = sameDay
    ? `Reporte fotogr√°fico ¬∑ ${startLong}`
    : `Reporte fotogr√°fico ¬∑ ${startLong} ‚Äî ${endLong}`;

  const projText = (tituloProyecto || "").trim();

  // Logo (opcional)
  const logoAb = await loadLogiLogoArrayBuffer();
  const logoRun = logoAb ? new ImageRun({ data: logoAb, transformation: { width: 38, height: 38 } }) : null;

  // Header moderno (tabla con 2 tonos + l√≠nea de acento)
  const headerTable = new Table({
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: noneBorders,
    rows: [
      new TableRow({
        children: [
          new TableCell({
            width: { size: 18, type: WidthType.PERCENTAGE },
            borders: noneBorders,
            shading: { fill: BRAND_DARK },
            verticalAlign: VerticalAlign.CENTER,
            margins: { top: 140, bottom: 140, left: 160, right: 120 },
            children: [
              new Paragraph({
                children: logoRun ? [logoRun] : [new TextRun({ text: " ", color: "FFFFFF" })],
                alignment: AlignmentType.LEFT,
              })
            ]
          }),
          new TableCell({
            width: { size: 82, type: WidthType.PERCENTAGE },
            borders: noneBorders,
            shading: { fill: BRAND_MID },
            verticalAlign: VerticalAlign.CENTER,
            margins: { top: 140, bottom: 140, left: 120, right: 220 },
            children: [
              new Paragraph({
                children: [new TextRun({ text: "Logi", bold: true, color: "FFFFFF", size: 44 })],
                alignment: AlignmentType.RIGHT,
                spacing: { before: 0, after: 40 }
              }),
              new Paragraph({
                children: [new TextRun({ text: titleLine, bold: true, color: "E5E7EB" })],
                alignment: AlignmentType.RIGHT,
                spacing: { before: 0, after: projText ? 30 : 0 }
              }),
              ...(projText ? [new Paragraph({
                children: [
                  new TextRun({ text: "Proyecto: ", bold: true, color: "CBD5E1" }),
                  new TextRun({ text: projText, color: "CBD5E1" }),
                ],
                alignment: AlignmentType.RIGHT,
                spacing: { before: 0, after: 0 }
              })] : [])
            ]
          })
        ]
      }),
      new TableRow({
        children: [
          new TableCell({
            borders: noneBorders,
            shading: { fill: BRAND_ACC },
            columnSpan: 2,
            margins: { top: 0, bottom: 0, left: 0, right: 0 },
            children: [ new Paragraph({ children: [new TextRun({ text: " " })] }) ]
          })
        ]
      })
    ]
  });

  const header = new Header({ children: [headerTable] });

  // Construcci√≥n de tabla: por cada par de fotos => 2 filas
  let pageRows = [];
  let pairCount = 0;
  let photoN = 1;
  const pages = [];

  const onProgress = exportOpts && exportOpts.onProgress ? exportOpts.onProgress : null;
  const _docxTotal = selected.length;
  let _docxDone = 0;

  async function makeImageCell(it){
    if (!it){
      return new TableCell({ width: { size: 50, type: WidthType.PERCENTAGE }, borders: gridBorders, children: [new Paragraph("")] });
    }

    const fixedBlob = await normalizeToFixedFrameJpg(it.blob, frameW, frameH, 0.9, fitMode);

    let finalBlob = fixedBlob;
    if (exportOpts?.applyLogo || exportOpts?.applyStamp || exportOpts?.applyTemplate){
      finalBlob = await applyExportOverlaysToBlob(fixedBlob, {
        addLogo: !!exportOpts.applyLogo,
        addStamp: !!exportOpts.applyStamp,
        stampText: exportOpts.applyStamp ? formatStampDateTime(it) : "",
        avoidDoubleLogo: !!(it.hasLogo && exportOpts.applyLogo),
        addTemplate: !!exportOpts.applyTemplate && (exportOpts.templateId !== "classic") && (exportOpts.templateId !== "clean"),
        templateLines: (!!exportOpts.applyTemplate && (exportOpts.templateId !== "classic") && (exportOpts.templateId !== "clean")) ? buildTemplateLines(getTemplateMeta(it), exportOpts.templateId) : [],
        logoCornerHint: localStorage.getItem("logi_logo_corner") || "br"
      });
    }

    const ab = await finalBlob.arrayBuffer();

    const img = new ImageRun({
      data: ab,
      transformation: { width: IMG_W, height: IMG_H }
    });

    if (it) {
      _docxDone++;
      if (onProgress) await onProgress(_docxDone, _docxTotal);
    }

    return new TableCell({
      width: { size: 50, type: WidthType.PERCENTAGE },
      borders: gridBorders,
      margins: { top: 80, bottom: 80, left: 80, right: 80 },
      children: [
        new Paragraph({
          children: [img],
          alignment: AlignmentType.CENTER,
          spacing: { before: 0, after: 0 }
        })
      ]
    });
  }

  function makeCaptionCell(it, n){
    if (!it){
      return new TableCell({ width: { size: 50, type: WidthType.PERCENTAGE }, borders: gridBorders, children: [new Paragraph("")] });
    }
    const meta = getTemplateMeta(it);
    const templateId = (exportOpts && exportOpts.templateId) ? exportOpts.templateId : "classic";
    const caption = buildDocxCaption(n, meta, templateId);
    const fontPt = _fitCaptionFontPt(caption);
    const sizeHp = Math.round(fontPt * 2);
    const runs = buildCaptionRunsSized(n, caption, sizeHp);

    return new TableCell({
      width: { size: 50, type: WidthType.PERCENTAGE },
      borders: gridBorders,
      margins: { top: 120, bottom: 120, left: 160, right: 120 },
      children: [
        new Paragraph({
          children: runs,
          spacing: { before: 0, after: 0 }
        })
      ]
    });
  }

  for (let i = 0; i < selected.length; i += 2){
    const left = selected[i] || null;
    const right = selected[i+1] || null;

    const nLeft = left ? photoN++ : null;
    const nRight = right ? photoN++ : null;

    const imageRow = new TableRow({
      children: [ await makeImageCell(left), await makeImageCell(right) ]
    });
    const captionRow = new TableRow({
      height: { value: CAPTION_ROW_H, rule: HeightRule.EXACT },
      children: [ makeCaptionCell(left, nLeft), makeCaptionCell(right, nRight) ]
    });

    pageRows.push(imageRow, captionRow);
    pairCount++;

    if (pairCount >= pairsPerPage){
      pages.push(pageRows);
      pageRows = [];
      pairCount = 0;
    }
  }
  if (pageRows.length) pages.push(pageRows);

  const children = [];
  pages.forEach((rows, idx) => {
    children.push(new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      borders: gridBorders,
      rows
    }));
});

  const doc = new Document({
    ...docDefaultStyles,
    sections: [{
      headers: { default: header },
      properties: {
        page: { margin: { top: 720, bottom: 720, left: 720, right: 720, header: 260 } }
      },
      children
    }]
  });

  const blob = await Packer.toBlob(doc);
  return await blob.arrayBuffer();
}

/* ===========================
   CSV + XLS
=========================== */
function buildManifestCsv(registros){
  const header = ["fecha","archivo","item","item_desc","descripcion","proyecto","listo"].join(";");
  const lines = [header];
  registros.forEach(r => {
    const desc = (r.descripcion || "").replaceAll('"','""');
    const proj = (r.proyecto || "").replaceAll('"','""');
    const item = (r.itemCode || "").replaceAll('"','""');
    const itemd = (r.itemDesc || "").replaceAll('"','""');
    lines.push([
      r.fecha,
      r.archivo,
      `"${item}"`,
      `"${itemd}"`,
      `"${desc}"`,
      `"${proj}"`,
      r.done ? "SI" : "NO"
    ].join(";"));
  });
  return lines.join("\n");
}

function buildManifestXlsHtml(registros){
  const esc = (s)=> String(s ?? "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  const rows = registros.map(r => `
    <tr>
      <td>${esc(r.fecha)}</td>
      <td>${esc(r.archivo)}</td>
      <td>${esc(r.itemCode)}</td>
      <td>${esc(r.itemDesc)}</td>
      <td>${esc(r.descripcion)}</td>
      <td>${esc(r.proyecto)}</td>
      <td>${r.done ? "SI" : "NO"}</td>
    </tr>
  `).join("");

  return `
  <html><head><meta charset="utf-8"></head><body>
  <table border="1">
    <tr><th>fecha</th><th>archivo</th><th>item</th><th>item_desc</th><th>descripcion</th><th>proyecto</th><th>listo</th></tr>
    ${rows}
  </table>
  </body></html>`;
}

const DOCX_IMG_W_CM = 7.6;
const DOCX_IMG_H_CM = 4.6;
const DOCX_PAIRS_PER_PAGE = 4; // 4 pares = 8 fotos por p√°gina

/* ===========================
   Export ZIP (incluye DOCX)
=========================== */
async function exportZipByMode(modo, desde, hasta){
  if (!window.JSZip){ alert("JSZip no carg√≥. Abre con internet o en Chrome."); return; }
  if (!window.docx){ alert("La librer√≠a DOCX no carg√≥. Abre con internet o en Chrome."); return; }

  const useTime = !!$("useTimeNames")?.checked;
  const onlyDone = !!$("onlyDone")?.checked;

  const exportLogo = !!$("exportLogo")?.checked;
  const exportStampDT = !!$("exportStampDT")?.checked;
  const exportTemplate = !!$("exportTemplate")?.checked;
  const templateId = getTemplateId();

  let selected = [];
  if (modo === "dia"){
    selected = cache.filter(x => x.fecha === desde);
  } else if (modo === "mes"){
    const ym = (desde || hoyISO()).slice(0,7);
    selected = cache.filter(x => (x.fecha || "").startsWith(ym));
  } else {
    const a = ymdToNum(desde);
    const b = ymdToNum(hasta);
    const lo = Math.min(a,b), hi = Math.max(a,b);
    selected = cache.filter(x => {
      const n = ymdToNum(x.fecha);
      return n >= lo && n <= hi;
    });
  }

  const itemFilter = getExportItemCode();
  if (itemFilter) selected = selected.filter(x => String(x.itemCode || "").trim() === itemFilter);

  if (onlyDone) selected = selected.filter(x => !!x.done);

  if (!selected.length){
    alert("No hay fotos en ese periodo" + (onlyDone ? " (o ninguna marcada como LISTA)." : "."));
    return;
  }

  selected.sort((a,b)=> (a.fecha.localeCompare(b.fecha) || a.createdAt - b.createdAt));

  const proyecto = sanitizeName(proyectoInput.value);
  let packName =
    (modo==="dia") ? `${desde}_${proyecto}` :
    (modo==="mes") ? `${(desde||hoyISO()).slice(0,7)}_${proyecto}` :
    `${desde}_a_${hasta}_${proyecto}`;
  const itemTag = itemFilter ? `_ITEM_${sanitizeName(itemFilter)}` : "";
  if (itemTag) packName = packName + itemTag;

  const zip = new JSZip();
  const root = zip.folder(packName);

  const perDayCounter = new Map();
  const manifestRows = [];

  zipInfo.textContent = `Armando ZIP (${selected.length} foto(s))...`;

  for (const it of selected){
    const folder = root.folder(it.fecha);

    const n = (perDayCounter.get(it.fecha) || 0) + 1;
    perDayCounter.set(it.fecha, n);

    const filename = filenameForItem(it, n, useTime);

    let outBlob = it.blob;
        if (exportLogo || exportStampDT || (exportTemplate && (templateId !== "classic") && (templateId !== "clean"))){
      outBlob = await applyExportOverlaysToBlob(it.blob, {
        addLogo: exportLogo && !!logoBitmap,
        addStamp: exportStampDT,
        stampText: exportStampDT ? formatStampDateTime(it) : "",
        avoidDoubleLogo: exportLogo && !!it.hasLogo,
        addTemplate: exportTemplate && (templateId !== "classic") && (templateId !== "clean"),
        templateLines: (exportTemplate && (templateId !== "classic") && (templateId !== "clean")) ? buildTemplateLines(getTemplateMeta(it), templateId) : [],
        logoCornerHint: localStorage.getItem("logi_logo_corner") || "br"
      });
    }

    folder.file(filename, outBlob);

    const descText = (it.descripcion || "").trim();
    folder.file(filename.replace(/\.jpg$/i,".txt"), descText || "");

    manifestRows.push({
      fecha: it.fecha,
      archivo: `${it.fecha}/${filename}`,
      itemCode: it.itemCode || "",
      itemDesc: it.itemDesc || "",
      descripcion: descText,
      proyecto: it.proyecto || "",
      done: !!it.done
    });
  }

  root.file("manifest.csv", buildManifestCsv(manifestRows));
  root.file("manifest.xls", buildManifestXlsHtml(manifestRows));
  const layoutKey = getLayoutKey();
  const { imgWcm: IMG_W_CM, imgHcm: IMG_H_CM, pairsPerPage: PAIRS_PER_PAGE } = docxDimsForLayout(layoutKey);

  const { start, end } = computeRangeForTitle(modo, desde, hasta);
  const tituloProyecto = (proyectoInput.value || "").trim();

  const zi = zipInfo;
  const totalDocx = selected.length;
  const nextPaint = () => new Promise(res => requestAnimationFrame(() => setTimeout(res, 0)));

  if (zi){ zi.textContent = `Generando DOCX... 0/${totalDocx}`; await nextPaint(); }

  const onProgress = async (done, tot) => {
    if (!zi) return;
    zi.textContent = `Generando DOCX... ${done}/${tot}`;
    await nextPaint();
  };

  const docxBuffer = await buildRegistroFotograficoDocxBuffer(
    selected, tituloProyecto, start, end, IMG_W_CM, IMG_H_CM, PAIRS_PER_PAGE,
    { applyLogo: exportLogo && !!logoBitmap, applyStamp: exportStampDT, applyTemplate: exportTemplate, templateId, onProgress }
  );

  const itemTag2 = itemFilter ? `_ITEM_${sanitizeName(itemFilter)}` : "";
  root.file(`Logi_Reporte_${start}_a_${end}${itemTag2}.docx`, docxBuffer);

  const outZipBlob = await zip.generateAsync({ type:"blob" }, (meta) => {
    zipInfo.textContent = `Comprimiendo... ${Math.floor(meta.percent)}%`;
  });

  const url = URL.createObjectURL(outZipBlob);
  const a = document.createElement("a");
  a.href = url;
  a.download = packName + ".zip";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  zipInfo.textContent = "ZIP descargado ‚úÖ";
  setTimeout(()=> zipInfo.textContent = "", 1800);
}

/* =========================
   Export Express (Paso 2D)
   PDF robusto con pdf-lib
   ========================= */

let _isExpressing = false;

async function shareBlobAsFile(blob, filename, mime, title) {
  const file = new File([blob], filename, { type: mime });

  if (navigator.share && (!navigator.canShare || navigator.canShare({ files: [file] }))) {
    try { await navigator.share({ files: [file], title: title || filename }); return true; }
    catch (e) { /* fallback */ }
  }

  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 2500);
  return false;
}

function wrapTextPdf(text, font, size, maxWidth, maxLines=0) {
  const clean = (text || "").replace(/\s+/g, " ").trim();
  if (!clean) return [];
  const words = clean.split(" ");
  const lines = [];
  let line = "";

  for (const w of words) {
    const test = line ? (line + " " + w) : w;
    if (font.widthOfTextAtSize(test, size) <= maxWidth) {
      line = test;
    } else {
      if (line) lines.push(line);
      line = w;
      if (maxLines && lines.length >= maxLines) break;
    }
  }
  if ((!maxLines || lines.length < maxLines) && line) lines.push(line);

  if (maxLines && lines.length === maxLines && words.length > 0) {
    // si recorta, a√±ade "‚Ä¶" al final si cabe
    const last = lines[lines.length - 1];
    const ell = last.endsWith("‚Ä¶") ? last : (last + "‚Ä¶");
    if (font.widthOfTextAtSize(ell, size) <= maxWidth) lines[lines.length - 1] = ell;
  }
  return lines;
}

async function buildRegistroFotograficoPdfBlob(selected, tituloProyecto, start, end, opts) {
  if (!window.PDFLib) {
    alert("PDFLib no carg√≥. Abre con internet o en Chrome y vuelve a intentar.");
    return null;
  }

  const { PDFDocument, StandardFonts, rgb } = PDFLib;
  const pdfDoc = await PDFDocument.create();
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const fontB = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  // A4 en puntos
  const pageW = 595.28;
  const pageH = 841.89;

  // === Estilo Logi (igual al DOCX) ===
  const BRAND_DARK = rgb(0x0B / 255, 0x12 / 255, 0x20 / 255);
  const BRAND_MID  = rgb(0x11 / 255, 0x1B / 255, 0x2E / 255);
  const BRAND_ACC  = rgb(0x3B / 255, 0x82 / 255, 0xF6 / 255);
  const GRID_COL   = rgb(0x2F / 255, 0x6F / 255, 0xED / 255);

  // === Header (dos tonos + l√≠nea acento) ===
  const headerMainH = 74;
  const headerAccH  = 6;
  const headerH     = headerMainH + headerAccH;
  const leftW       = pageW * 0.18;
  const rightW      = pageW - leftW;

  // === M√°rgenes / grilla (2 columnas) ===
  const layoutKey = (opts && opts.layoutKey) ? opts.layoutKey : getLayoutKey();
  const { rows } = layoutFromKey(layoutKey);
  const cols = 2;

  const marginX = 36;
  const colGap  = 12;

  const gridLeft = marginX;
  const gridRight = pageW - marginX;
  const cellW = (gridRight - gridLeft - colGap) / cols;

  const gridTop = pageH - headerH - 18;  // espacio bajo el membrete
  const gridBottom = 36;                 // espacio inferior (paginaci√≥n)

  const captionH = 34; // similar a la fila de caption del DOCX
  const imgBoxH = Math.max(120, (gridTop - gridBottom - rows * captionH) / rows);
  const pad = 6;

  // Normalizaci√≥n (misma relaci√≥n que DOCX)
  const IMG_W_CM = 7.6;
  const IMG_H_CM = 4.6;
  const ratio = IMG_W_CM / IMG_H_CM;
  const frameW = 1600;
  const frameH = Math.round(frameW / ratio);
  const fitMode = localStorage.getItem("logi_docx_fit") || "stretch";

  const startLong = (typeof formatDateLongES === "function") ? formatDateLongES(start) : start;
  const endLong   = (typeof formatDateLongES === "function") ? formatDateLongES(end) : end;
  const sameDay = (start === end);
  const titleLine = sameDay
    ? `Reporte fotogr√°fico ¬∑ ${startLong}`
    : `Reporte fotogr√°fico ¬∑ ${startLong} ‚Äî ${endLong}`;

  const projText = (tituloProyecto || "").trim();

  // Logo (opcional)
  let logoImg = null;
  try{
    const logoAb = await loadLogiLogoArrayBuffer();
    if (logoAb){
      const u8 = new Uint8Array(logoAb);
      const isPng = (u8[0] === 0x89 && u8[1] === 0x50 && u8[2] === 0x4E && u8[3] === 0x47);
      logoImg = isPng ? await pdfDoc.embedPng(u8) : await pdfDoc.embedJpg(u8);
    }
  }catch{ logoImg = null; }

  // Paginaci√≥n: 8 fotos por p√°gina (como DOCX)
  const MODULES_PER_PAGE = rows * cols;
  const totalPages = Math.max(1, Math.ceil(selected.length / MODULES_PER_PAGE));

  let done = 0;
  let photoN = 1;

  function drawRightText(page, txt, y, size, bold=false, color=rgb(1,1,1), padRight=28){
    const f = bold ? fontB : font;
    const w = f.widthOfTextAtSize(txt, size);
    page.drawText(txt, { x: pageW - padRight - w, y, size, font: f, color });
  }

  function splitWords(s){ return (s || "").trim().split(/\s+/).filter(Boolean); }

  function wrapRestLines(restText, fnt, size, maxWidth, maxLines){
    const words = splitWords(restText);
    const lines = [];
    let line = "";
    for (const w of words){
      const test = line ? (line + " " + w) : w;
      if (fnt.widthOfTextAtSize(test, size) <= maxWidth){
        line = test;
      } else {
        if (line) lines.push(line);
        line = w;
        if (maxLines && lines.length >= maxLines) break;
      }
    }
    if ((!maxLines || lines.length < maxLines) && line) lines.push(line);

    if (maxLines && lines.length === maxLines && words.length){
      const last = lines[lines.length-1];
      const ell = last.endsWith("‚Ä¶") ? last : (last + "‚Ä¶");
      if (fnt.widthOfTextAtSize(ell, size) <= maxWidth) lines[lines.length-1] = ell;
    }
    return lines;
  }

  function drawCaption(page, captionText, x, yTop, w){
    // Ajuste autom√°tico + partici√≥n de tokens largos (para que NUNCA se salga del recuadro)
    const maxW = w - pad*2;
    const boxH = captionH - pad*2;

    // Detecta prefijo real
    const prefixNew = `Foto No. ${photoN-1},`;
    const prefixOld = `FOTO ${photoN-1}.`;
    let prefix = "";
    if (captionText.startsWith(prefixNew)) prefix = prefixNew;
    else if (captionText.startsWith(prefixOld)) prefix = prefixOld;

    const restRaw = prefix ? captionText.slice(prefix.length).trimStart() : captionText;

    const splitWords = (s) => (String(s||"").replace(/\s+/g," ").trim().split(" ").filter(Boolean));

    const splitTokenByWidth = (tok, fnt, size, wLim) => {
      const parts = [];
      let chunk = "";
      for (const ch of tok){
        const t = chunk + ch;
        if (fnt.widthOfTextAtSize(t, size) <= wLim || !chunk){
          chunk = t;
        } else {
          parts.push(chunk);
          chunk = ch;
        }
      }
      if (chunk) parts.push(chunk);
      return parts;
    };

    const takeLine = (tokens, fnt, size, wLim) => {
      let line = "";
      let i = 0;
      while (i < tokens.length){
        let tok = tokens[i];

        // token gigante al inicio -> partirlo
        if (!line && fnt.widthOfTextAtSize(tok, size) > wLim){
          const parts = splitTokenByWidth(tok, fnt, size, wLim);
          line = parts[0] || "";
          const rest = parts.slice(1).concat(tokens.slice(i+1));
          return { line, restTokens: rest };
        }

        const test = line ? (line + " " + tok) : tok;
        if (fnt.widthOfTextAtSize(test, size) <= wLim){
          line = test;
          i++;
        } else {
          break;
        }
      }
      return { line, restTokens: tokens.slice(i) };
    };

    const wrapTokens = (tokens, fnt, size, wLim, maxLines) => {
      const lines = [];
      let rest = tokens.slice();
      while (rest.length && (!maxLines || lines.length < maxLines)){
        const r = takeLine(rest, fnt, size, wLim);
        if (r.line) lines.push(r.line);
        rest = r.restTokens;
        if (!r.line && rest.length) { lines.push(rest.shift()); }
      }
      return lines;
    };

    const layoutAtSize = (size) => {
      const lineH = size + 1.5; // ~11 cuando size=9.5
      const spaceW = prefix ? font.widthOfTextAtSize(" ", size) : 0;
      const prefixW = prefix ? fontB.widthOfTextAtSize(prefix, size) : 0;
      const firstMax = prefix ? Math.max(20, maxW - prefixW - spaceW) : maxW;

      const restTokens = splitWords(restRaw);
      // 1ra l√≠nea (resto) con ancho reducido si hay prefijo
      const first = takeLine(restTokens, font, size, firstMax);
      const otherLines = wrapTokens(first.restTokens, font, size, maxW, 3); // total 4 l√≠neas

      const reqH = lineH * (1 + otherLines.length);
      return { size, lineH, spaceW, prefixW, firstRest: first.line || "", otherLines, reqH };
    };

    // B√∫squeda binaria del tama√±o m√°ximo que quepa en altura (y respete 4 l√≠neas)
    let lo = _CAPTION_FONT_PT_MIN;
    let hi = _CAPTION_FONT_PT_BASE;
    let best = layoutAtSize(lo);

    for (let i=0; i<10; i++){
      const mid = (lo + hi) / 2;
      const L = layoutAtSize(mid);
      if (L.reqH <= boxH){
        best = L;
        lo = mid;
      } else {
        hi = mid;
      }
    }

    const size = Math.max(_CAPTION_FONT_PT_MIN, Math.min(_CAPTION_FONT_PT_BASE, Math.round(best.size*10)/10));
    const L = layoutAtSize(size);

    // Dibujo
    let y = yTop - pad - (size + 0.5);

    if (prefix){
      page.drawText(prefix, { x: x + pad, y, size, font: fontB, color: rgb(0,0,0) });
      const xRest = x + pad + L.prefixW + L.spaceW;
      if (L.firstRest) page.drawText(L.firstRest, { x: xRest, y, size, font, color: rgb(0,0,0) });
    } else {
      if (L.firstRest) page.drawText(L.firstRest, { x: x + pad, y, size, font, color: rgb(0,0,0) });
    }

    y -= L.lineH;
    for (const line of L.otherLines){
      page.drawText(line, { x: x + pad, y, size, font, color: rgb(0,0,0) });
      y -= L.lineH;
    }
  }

  for (let p = 0; p < totalPages; p++) {
    const page = pdfDoc.addPage([pageW, pageH]);

    // ===== Header =====
    const headerY = pageH - headerMainH;

    page.drawRectangle({ x: 0, y: headerY, width: leftW, height: headerMainH, color: BRAND_DARK });
    page.drawRectangle({ x: leftW, y: headerY, width: rightW, height: headerMainH, color: BRAND_MID });
    page.drawRectangle({ x: 0, y: pageH - headerH, width: pageW, height: headerAccH, color: BRAND_ACC });

    // Logo centrado en bloque izquierdo
    if (logoImg){
      const s = 38;
      const xLogo = (leftW - s) / 2;
      const yLogo = headerY + (headerMainH - s) / 2;
      page.drawImage(logoImg, { x: xLogo, y: yLogo, width: s, height: s });
    }

    // Textos a la derecha (alineados a la derecha)
    drawRightText(page, "Logi", pageH - 30, 22, true, rgb(1,1,1));
    drawRightText(page, titleLine, pageH - 50, 10.5, true, rgb(0xE5/255,0xE7/255,0xEB/255));
    if (projText){
      const projLine = `Proyecto: ${projText}`;
      drawRightText(page, projLine, pageH - 65, 10, false, rgb(0xCB/255,0xD5/255,0xE1/255));
    }

    // ===== Grid =====
    for (let row = 0; row < rows; row++){
      for (let col = 0; col < cols; col++){
        const idx = p * MODULES_PER_PAGE + row*cols + col;
        if (idx >= selected.length) break;

        const it = selected[idx];
        done++;

        // aplica overlays si est√°n activados (logo/sello/plantilla)
        let imgBlob = it.blob;

        const wantsTemplate = !!(opts.applyTemplate && (opts.templateId !== "classic") && (opts.templateId !== "clean"));

        if (opts.applyLogo || opts.applyStamp || wantsTemplate) {
          imgBlob = await applyExportOverlaysToBlob(it.blob, {
            addLogo: opts.applyLogo && !!logoBitmap,
            addStamp: opts.applyStamp,
            stampText: opts.applyStamp ? formatStampDateTime(it) : "",
            avoidDoubleLogo: opts.applyLogo && !!it.hasLogo,
            addTemplate: wantsTemplate,
            templateLines: wantsTemplate ? buildTemplateLines(getTemplateMeta(it), opts.templateId) : [],
            logoCornerHint: localStorage.getItem("logi_logo_corner") || "br"
          });
        }

        // normaliza a marco fijo (como en DOCX) para que todo quede consistente
        try{ imgBlob = await normalizeToFixedFrameJpg(imgBlob, frameW, frameH, 0.9, fitMode); }catch{}

        const ab = await imgBlob.arrayBuffer();
        const u8 = new Uint8Array(ab);

        const isPng = (u8[0] === 0x89 && u8[1] === 0x50 && u8[2] === 0x4E && u8[3] === 0x47);
        const img = isPng ? await pdfDoc.embedPng(u8) : await pdfDoc.embedJpg(u8);

        const cellX = gridLeft + col * (cellW + colGap);

        const rowTop = gridTop - row * (imgBoxH + captionH);
        const imgY = rowTop - imgBoxH;
        const capTop = imgY;
        const capY = capTop - captionH;

        // Bordes (imagen + caption) ‚Äî mismo color del DOCX
        page.drawRectangle({ x: cellX, y: imgY, width: cellW, height: imgBoxH, borderColor: GRID_COL, borderWidth: 1 });
        page.drawRectangle({ x: cellX, y: capY, width: cellW, height: captionH, borderColor: GRID_COL, borderWidth: 1 });

        // Dibuja imagen centrada dentro de su caja
        const maxImgW = cellW - pad * 2;
        const maxImgH = imgBoxH - pad * 2;

        const scale = Math.min(maxImgW / img.width, maxImgH / img.height);
        const drawW = img.width * scale;
        const drawH = img.height * scale;

        const xImg = cellX + pad + (maxImgW - drawW) / 2;
        const yImg = imgY + pad + (maxImgH - drawH) / 2;

        page.drawImage(img, { x: xImg, y: yImg, width: drawW, height: drawH });

        // Caption (mismo constructor que DOCX)
        const meta = getTemplateMeta(it);
        const capText = buildDocxCaption(photoN, meta, opts.templateId);
        photoN++;

        // Fondo blanco para caption (por si el PDF queda con transparencia)
        page.drawRectangle({ x: cellX+1, y: capY+1, width: cellW-2, height: captionH-2, color: rgb(1,1,1) });

        drawCaption(page, capText, cellX, capTop, cellW);

        // progreso UI
        if ($("zipInfo")) $("zipInfo").textContent = `Generando PDF... ${done}/${selected.length}`;
        await new Promise(r => setTimeout(r, 0));
      }
    }

    // ===== Footer =====
    page.drawText(`${p + 1}/${totalPages}`, {
      x: pageW - marginX - 45,
      y: 16,
      size: 9,
      font,
      color: rgb(0.35,0.4,0.5)
    });
  }

  const bytes = await pdfDoc.save();
  return new Blob([bytes], { type: "application/pdf" });
}


async function exportExpressByMode(modo, desde, hasta, fmt) {
  if (_isExpressing) return;
  _isExpressing = true;

  const btn = $("btnExpress");
  const btnZip = $("btnZip");
  const btnZipHoy = $("btnZipHoy");
  if (btn) btn.disabled = true;
  if (btnZip) btnZip.disabled = true;
  if (btnZipHoy) btnZipHoy.disabled = true;

  try {
    if (fmt === "zip"){
      await exportZipByMode(modo, desde, hasta);
      const zi = $("zipInfo");
      if (zi) { zi.textContent = "ZIP descargado ‚úÖ"; setTimeout(()=> zi.textContent = "", 1800); }
      return;
    }

    const useTime = !!$("useTimeNames")?.checked;
    const onlyDone = !!$("onlyDone")?.checked;

    const exportLogo = !!$("exportLogo")?.checked;
    const exportStampDT = !!$("exportStampDT")?.checked;
    const exportTemplate = !!$("exportTemplate")?.checked;
    const templateId = getTemplateId();

    let selected = [];
    if (modo === "dia") {
      selected = cache.filter(x => x.fecha === desde);
    } else if (modo === "mes") {
      selected = cache.filter(x => (x.fecha || "").startsWith(desde.slice(0,7)));
    } else {
      selected = cache.filter(x => x.fecha >= desde && x.fecha <= hasta);
    }

    const itemFilter = getExportItemCode();
  if (itemFilter) selected = selected.filter(x => String(x.itemCode || "").trim() === itemFilter);

  if (onlyDone) selected = selected.filter(x => !!x.done);

    if (!selected.length) {
      alert("No hay fotos en ese rango / filtro.");
      return;
    }

    const start = (modo === "mes") ? desde.slice(0,7) : desde;
    const end   = (modo === "rango") ? hasta : ((modo === "mes") ? desde.slice(0,7) : desde);

    const tituloProyecto = (proyectoInput.value || "").trim();

    if (fmt === "docx") {
      if (!window.docx) {
        alert("La librer√≠a DOCX no carg√≥. Abre con internet o en Chrome.");
        return;
      }
      const layoutKey = getLayoutKey();
      const { imgWcm: IMG_W_CM, imgHcm: IMG_H_CM, pairsPerPage: PAIRS_PER_PAGE } = docxDimsForLayout(layoutKey);

      const zi = $("zipInfo");
      const total = selected.length;
      const nextPaint = () => new Promise(res => requestAnimationFrame(() => setTimeout(res, 0)));

      if (zi){ zi.textContent = `Generando Word... 0/${total}`; await nextPaint(); }

      const onProgress = async (done, tot) => {
        if (!zi) return;
        zi.textContent = `Generando Word... ${done}/${tot}`;
        await nextPaint();
      };

      const docxBuffer = await buildRegistroFotograficoDocxBuffer(
        selected, tituloProyecto, start, end, IMG_W_CM, IMG_H_CM, PAIRS_PER_PAGE,
        { applyLogo: exportLogo && !!logoBitmap, applyStamp: exportStampDT, applyTemplate: exportTemplate, templateId, onProgress }
      );

      const blob = new Blob([docxBuffer], { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });
      const itemTag = itemFilter ? `_ITEM_${sanitizeName(itemFilter)}` : "";
      await shareBlobAsFile(blob, `Logi_Reporte_${start}_a_${end}${itemTag}.docx`, blob.type, "Logi - Word");
      $("zipInfo").textContent = "Word listo ‚úÖ";
      setTimeout(()=> $("zipInfo").textContent = "", 1800);
      return;
    }

    // PDF
    $("zipInfo").textContent = "Generando PDF...";
    const pdfBlob = await buildRegistroFotograficoPdfBlob(selected, tituloProyecto, start, end, {
      applyLogo: exportLogo && !!logoBitmap,
      applyStamp: exportStampDT,
      applyTemplate: exportTemplate,
      templateId,
      layoutKey: getLayoutKey()
    });

    if (!pdfBlob) return;

    const itemTag = itemFilter ? `_ITEM_${sanitizeName(itemFilter)}` : "";
    await shareBlobAsFile(pdfBlob, `Logi_Reporte_${start}_a_${end}${itemTag}.pdf`, "application/pdf", "Logi - PDF");
    $("zipInfo").textContent = "PDF listo ‚úÖ";
    setTimeout(()=> $("zipInfo").textContent = "", 1800);

  } finally {
    _isExpressing = false;
    if (btn) btn.disabled = false;
    if (btnZip) btnZip.disabled = false;
    if (btnZipHoy) btnZipHoy.disabled = false;
  }
}

if ($("btnExpress")) {
  $("btnExpress").onclick = async () => {
    const fmt = $("expressFormat")?.value || "docx";
    const modo = $("modoExport").value;
    const desde = $("desde").value || (fechaInput.value || hoyISO());
    let hasta = $("hasta").value || (fechaInput.value || hoyISO());
    if (modo !== "rango") hasta = desde;
    await exportExpressByMode(modo, desde, hasta, fmt);
  };
}




function updateExportUI(){
  const modo = $("modoExport").value;
  const hastaWrap = $("hastaWrap");
  const desdeLabel = $("desdeLabel");
  const desdeEl = $("desde");

  // Cambia el picker seg√∫n el modo:
  // - D√≠a/Rango: type=date (YYYY-MM-DD)
  // - Mes: type=month (YYYY-MM)
  const toMonth = () => {
    const current = String(desdeEl.value || "");
    const ym = (current.length >= 7 ? current.slice(0,7) : hoyISO().slice(0,7));
    if (desdeEl.type !== "month") {
      try { desdeEl.type = "month"; } catch(e) {}
    }
    desdeEl.value = ym;
  };
  const toDate = () => {
    const current = String(desdeEl.value || "");
    const ymd = (current.length === 7 ? `${current}-01` : (current || hoyISO()));
    if (desdeEl.type !== "date") {
      try { desdeEl.type = "date"; } catch(e) {}
    }
    desdeEl.value = ymd;
  };

  if (modo === "rango"){
    toDate();
    hastaWrap.style.display = "block";
    desdeLabel.textContent = "Desde";
  } else if (modo === "dia"){
    toDate();
    hastaWrap.style.display = "none";
    desdeLabel.textContent = "D√≠a";
    $("hasta").value = $("desde").value; // d√≠a usa solo "desde"
  } else { // mes
    hastaWrap.style.display = "none";
    desdeLabel.textContent = "Mes";
    toMonth();
    // Mantener "hasta" como fecha v√°lida por si luego cambian a rango.
    const ym = String($("desde").value || hoyISO()).slice(0,7);
    $("hasta").value = `${ym}-01`;
  }
}

$("modoExport")?.addEventListener("change", updateExportUI);
$("desde")?.addEventListener("change", () => {
  const modo = $("modoExport").value;
  if (modo !== "rango") {
    if (modo === "mes") {
      const ym = String($("desde").value || hoyISO()).slice(0,7);
      $("hasta").value = `${ym}-01`;
    } else {
      $("hasta").value = $("desde").value;
    }
  }
  updateExportUI();

  initLayoutUI();

// Preferencias persistentes
  if (proyectoInput) proyectoInput.value = getProjectDefault();
  syncTemplateUI();
});


const __btnDelProj = $("btnDeleteProject");
if (__btnDelProj) __btnDelProj.onclick = async () => {
  const sel = $("deleteProjectSelect");
  const pid = sel ? sel.value : "";
  const { projects, activeId } = ensureProjects();
  if (!pid) return;

  if (projects.length <= 1){
    alert("No puedes eliminar el √∫ltimo proyecto.");
    return;
  }

  const p = projects.find(x => x.id === pid);
  const name = p ? p.name : pid;

  const ok = confirm(`¬øEliminar el proyecto "${name}"?\n\n‚Ä¢ Se borrar√°n TODAS sus fotos y sus √≠tems (cat√°logo) en este dispositivo.\n‚Ä¢ Esta acci√≥n no se puede deshacer.`);
  if (!ok) return;

  try{
    $("backupStatus").textContent = "Eliminando proyecto‚Ä¶";
    const prog = $("backupProgress");
    if (prog){ prog.style.display = "block"; prog.max = 100; prog.value = 0; }

    await deleteProjectData(pid);

    // quitar de lista de proyectos
    const next = projects.filter(x => x.id !== pid);
    saveProjects(next);

    // si era el activo, mover activo al primero
    if (activeId === pid){
      setActiveProjectId(next[0].id);
    }

    // refrescar
    await loadCacheForActiveProject();
    await loadCatalogForActiveProject();
    refreshProjectUI();
    updateStorageUI();
    render();

    if (prog){ prog.style.display = "none"; prog.value = 0; prog.max = 100; }
    $("backupStatus").textContent = "Proyecto eliminado ‚úÖ";
    setTimeout(() => { $("backupStatus").textContent = "Consejo: haz backup al final del d√≠a o antes de actualizar."; }, 2500);
  }catch(e){
    console.error(e);
    alert("No pude eliminar el proyecto. Intenta cerrar la app y volver a abrir.");
    $("backupStatus").textContent = "‚Äî";
  }
};

$("btnBorrarTodo").onclick = async () => {
  if (!confirm("¬øBorrar TODO (todas las fotos y descripciones del dispositivo)?")) return;
  await dbClear();
  cache = [];
  render();
};

/* ===========================
   Tabs + render
=========================== */
function setTab(mode){
  viewMode = mode;

  $("tabCaptura").classList.toggle("active", mode === "captura");
  $("tabGaleria").classList.toggle("active", mode === "galeria");
  $("tabExport")?.classList.toggle("active", mode === "export");

  $("capturaView").style.display = mode === "captura" ? "block" : "none";
  $("galeriaView").style.display = mode === "galeria" ? "block" : "none";
  const cc = $("capturaControls");
  if (cc) cc.style.display = mode === "captura" ? "block" : "none";
  const ev = $("exportView");
  if (ev) ev.style.display = mode === "export" ? "block" : "none";

  const ri = $("rangeInfo");
  if (ri) ri.style.display = (mode === "galeria") ? "block" : "none";

  render();
}
$("tabCaptura").onclick = () => setTab("captura");
$("tabGaleria").onclick = () => setTab("galeria");
$("tabExport").onclick = () => setTab("export");

function initSwipeTabs(){
  const order = ["captura","galeria","export"];
  let startX = null;
  let startY = null;
  let started = false;

  const isFormEl = (el) => {
    if (!el) return false;
    const t = (el.tagName||"").toLowerCase();
    return ["input","textarea","select","button","label"].includes(t) || el.closest?.("input,textarea,select,button,label");
  };

  document.addEventListener("touchstart", (e) => {
    const t = e.touches && e.touches[0];
    if (!t) return;
    if (isFormEl(e.target)) { started = false; startX = startY = null; return; }
    started = true;
    startX = t.clientX;
    startY = t.clientY;
  }, { passive: true });

  document.addEventListener("touchend", (e) => {
    if (!started || startX == null) return;
    const t = e.changedTouches && e.changedTouches[0];
    if (!t) return;
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;
    startX = startY = null;
    started = false;

    // Ignora gestos verticales
    if (Math.abs(dy) > Math.abs(dx)) return;

    if (Math.abs(dx) < 70) return;

    const i = Math.max(0, order.indexOf(viewMode));
    if (dx < 0){ // izquierda
      const next = order[Math.min(order.length-1, i+1)];
      setTab(next);
    } else { // derecha
      const prev = order[Math.max(0, i-1)];
      setTab(prev);
    }
  }, { passive: true });
}

function render(){
  revokeActiveUrls();
  setStatus();
  if (viewMode === "captura") renderCaptura();
  else if (viewMode === "galeria") renderGaleria();
  else renderExport();
}

function renderExport(){
  // En exportaci√≥n solo necesitamos estado; el resto ya est√° en el DOM
}


/* ===========================
   Init
=========================== */
(async function init(){

(async function migrateFromRFIfNeeded(){
  try{
    // Si ya hay data en Logi, no hacemos nada
    const current = await dbGetAll();
    if (current && current.length) return;

    // Intentar leer DB legacy (RF)
    const legacyName = "rf_db_v1";
    const legacy = await (async () => new Promise((resolve) => {
      const req = indexedDB.open(legacyName, 1);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => resolve(null);
    }))();
    if (!legacy) return;

    const legacyItems = await new Promise((resolve) => {
      try{
        const tx = legacy.transaction("items", "readonly");
        const req = tx.objectStore("items").getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => resolve([]);
      }catch{ resolve([]); }
    });

    if (!legacyItems.length) return;

    const ok = confirm(`Encontr√© ${legacyItems.length} foto(s) de una versi√≥n anterior (RF).\n\n¬øQuieres IMPORTARLAS a Logi? (No borra nada de RF)`);
    if (!ok) return;

    for (const it of legacyItems){
      await dbPut(it);
      cache.push(it);
    }

    // Migrar settings (solo si Logi no tiene nada a√∫n)
    const mapKeys = [
      ["rf_theme","logi_theme"],
      ["rf_accent","logi_accent"],
      ["rf_project","logi_project"],
      ["rf_template","logi_template"],
      ["rf_logo_enabled","logi_logo_enabled"],
      ["rf_logo_dataurl","logi_logo_dataurl"],
      ["rf_logo_corner","logi_logo_corner"],
      ["rf_docx_fit","logi_docx_fit"],
    ];
    for (const [oldK,newK] of mapKeys){
      if (localStorage.getItem(newK) == null && localStorage.getItem(oldK) != null){
        localStorage.setItem(newK, localStorage.getItem(oldK));
      }
    }

    render();
    alert("Listo ‚úÖ Import√© las fotos y ajustes desde RF hacia Logi.");
  }catch{}
})(); 

  const today = hoyISO();
  fechaInput.value = today;
  $("desde").value = today;
  $("hasta").value = today;

  updateExportUI();

  initLayoutUI();

  // Export: filtro por √≠tem (opcional)
  if ($("exportItem")) {
    $("exportItem").addEventListener("input", updateExportItemHint);
  }
  if ($("btnClearExportItem")) {
    $("btnClearExportItem").onclick = () => {
      if ($("exportItem")) $("exportItem").value = "";
      updateExportItemHint();
    };
  }
  updateExportItemHint();

  // Filtro por √≠tem en Galer√≠a
  if ($("galleryItem")){
    $("galleryItem").addEventListener("input", () => {
      updateGalleryItemHint();
      if (viewMode === "galeria") render();
    });
    $("galleryItem").addEventListener("change", () => {
      updateGalleryItemHint();
      if (viewMode === "galeria") render();
    });
  }
  if ($("btnGalleryItemClear")){
    $("btnGalleryItemClear").onclick = () => {
      if ($("galleryItem")) $("galleryItem").value = "";
      updateGalleryItemHint();
      if (viewMode === "galeria") render();
    };
  }
  updateGalleryItemHint();

  // Multi-proyecto (Logi2)
  ensureProjects();
  refreshProjectUI();
  attachProjectHandlers();

  initSwipeTabs();

  initTheme();
  initAccent();

  loadDocxFit();
  await loadLogoFromStorage();
  loadLogoCorner();

  try{
    await loadCacheForActiveProject();
    await loadCatalogForActiveProject();
    const ri = $("rangeInfo");
    if (ri) ri.style.display = "none";
    render();
  }catch{
    alert("No se pudo abrir la base local (IndexedDB). Prueba Chrome.");
  }

  fechaInput.onchange = () => render();
})();
</script>
</body>
</html>
